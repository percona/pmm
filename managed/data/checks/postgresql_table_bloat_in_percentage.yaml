---
checks:
  - version: 1
    name: postgresql_table_bloat_in_percentage
    summary: PostgreSQL Table Bloat in percentage of the table size
    description: This check verifies the size of the table bloat in percentage of the total table size and alert accordingly
    type: POSTGRESQL_SELECT
    #family: postgresql
    #author: David Gonzalez
    advisor: performance_vacuum
    interval: standard
    query: |
      * FROM (
      WITH a AS (
      SELECT current_database(), schemaname, tblname, tblpages as pages,est_tblpages as est_pages ,est_tblpages_ff as est_pages_ff,
      bs*tblpages AS cur_size_byte, (tblpages-est_tblpages)*bs AS free_bytes,
      CASE WHEN tblpages - est_tblpages > 0
          THEN 100 * (tblpages - est_tblpages)/tblpages::float
          ELSE 0
      END AS extra_pages_pct, fillfactor,
      CASE WHEN tblpages - est_tblpages_ff > 0
          THEN (tblpages-est_tblpages_ff)*bs
          ELSE 0
      END AS bloatsize_byte,
      CASE WHEN tblpages - est_tblpages_ff > 0
          THEN 100 * (tblpages - est_tblpages_ff)/tblpages::float
          ELSE 0
      END AS bloat_pct, is_na AS stats_missing
      FROM (
      SELECT ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) AS est_tblpages,
          ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,
          tblpages, fillfactor, bs, tblid, schemaname, tblname, heappages, toastpages, is_na
      FROM (
          SELECT
          ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)
              - CASE WHEN tpl_hdr_size%ma = 0 THEN ma ELSE tpl_hdr_size%ma END
              - CASE WHEN ceil(tpl_data_size)::int%ma = 0 THEN ma ELSE ceil(tpl_data_size)::int%ma END
          ) AS tpl_size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages, heappages,
          toastpages, reltuples, toasttuples, bs, page_hdr, tblid, schemaname, tblname, fillfactor, is_na
          FROM (
          SELECT
              tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tblname, tbl.reltuples,
              tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,
              coalesce(toast.reltuples, 0) AS toasttuples,
              coalesce(substring(
              array_to_string(tbl.reloptions, ' ')
              FROM 'fillfactor=([0-9]+)')::smallint, 100) AS fillfactor,
              current_setting('block_size')::numeric AS bs,
              CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,
              24 AS page_hdr,
              23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END
              + CASE WHEN bool_or(att.attname = 'oid' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,
              sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 0) ) AS tpl_data_size,
              bool_or(att.atttypid = 'pg_catalog.name'::regtype)
              OR sum(CASE WHEN att.attnum > 0 THEN 1 ELSE 0 END) <> count(s.attname) AS is_na
          FROM pg_attribute AS att
              JOIN pg_class AS tbl ON att.attrelid = tbl.oid
              JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace
                  AND ns.nspname NOT IN ('pg_catalog', 'information_schema')
              LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname
              AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname
              LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid
          WHERE NOT att.attisdropped
              AND tbl.relkind in ('r','m')
          GROUP BY 1,2,3,4,5,6,7,8,9,10
          ORDER BY 2,3
          ) AS s
      ) AS s2
      ) AS s3
      ORDER BY schemaname, tblname)
      SELECT  current_database,
              schemaname,
              tblname,
              cur_size_byte real_size,
              pg_size_pretty(cur_size_byte::numeric) real_size_pretty,
              bloatsize_byte bloat_size_byte,
              pg_size_pretty(bloatsize_byte::numeric) bloat_size_byte_pretty,
              bloat_pct::numeric(4,0) as bloat_percentage
      FROM a
      WHERE schemaname != 'pg_catalog'
      AND bloatsize_byte > 1073741824
      ORDER BY cur_size_byte DESC
      ) x
    script: |
      read_url = "https://docs.percona.com/percona-platform/advisors/checks/{}.html"

      # pg_advisor
      def check(rows):
          # for compatibility with PMM Server < 2.12
          context = {
              "format_version_num": format_version_num,
              "parse_version": parse_version,
          }
          return check_context(rows, context)

      # threshold
      check_threshold = {
          "warning": 20,
          "critical": 50
      }

      def check_context(rows, context):
          # `rows` is a frozen (deeply immutable) list of dicts where each dict represents a single row in SQL result.
          # `context` is a dict with additional functions.
          #
          # Global `print` and `fail` functions are available.
          #
          # `check_context` function is expected to return a list of dicts that are then converted to alerts;
          # in particular, that list can be empty.
          # Any other value (for example, string) is treated as script execution failure
          # (Starlark does not support Python exceptions);
          # it is recommended to use global function `fail` for that instead.
          """
          This check verifies the table bloat in percentage of the total table size, in the database where PMM connects.
          There is no need to run this command more than once per database cluster.
          This check returns warning if there is any table with a bloat larger than 1GB and this is at least the 20% of the table total size.
          This check returns error if there is any table with a bloat larger than 1GB and this is at least the 50% of the table total size.
          Error is returned if for any reason there are no results from query.
          """
          results = []
          # extract information from variables
          for row in rows:
              current_database, schemaname, tblname = row["current_database"], row["schemaname"], row["tblname"]
              real_size, real_size_pretty = int(row["real_size"]), row["real_size_pretty"]
              bloat_size_byte, bloat_size_byte_pretty = int(row["bloat_size_byte"]), row["bloat_size_byte_pretty"]
              bloat_percentage = int(row["bloat_percentage"])
              if bloat_percentage >= check_threshold["critical"]:
                  results.append({
                      "summary": "Table Bloat in percentage of table size is high",
                      "description": "Table {}.{} in database {} has a bloat of {}% from total table size of {}".format(schemaname, tblname, current_database, bloat_percentage, real_size_pretty),
                      "read_more_url": read_url.format("postgresql-table-bloat-in-percentage-of-table-size"),
                      "severity": "error"
                  })
              elif bloat_percentage >= check_threshold["warning"]:
                  results.append({
                      "summary": "Table Bloat in percentage of table size is high",
                      "description": "Table {}.{} in database {} has a bloat of {}% from total table size of {}".format(schemaname, tblname, current_database, bloat_percentage, real_size_pretty),
                      "read_more_url": read_url.format("postgresql-table-bloat-in-percentage-of-table-size"),
                      "severity": "warning"
                  })
          return results
