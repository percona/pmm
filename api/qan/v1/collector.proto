syntax = "proto3";

package qan.v1;

import "inventory/v1/agents.proto";
import "qan/v1/qan.proto";

// Collector service accepts data from pmm-agent (via pmm-managed).
service CollectorService {
  // Collect accepts data from pmm-agent (via pmm-managed).
  rpc Collect(CollectRequest) returns (CollectResponse);
}

message CollectRequest {
  repeated MetricsBucket metrics_bucket = 1;
}

// MetricsBucket is aggregated message created by pmm-agent.
// Contains information about one query selected in defined way from query class in specific period of time.
message MetricsBucket {
  // md5 of digest_text/fingerprint.
  string queryid = 1;
  // contains fingerprint prepared by sql parser, which can be different than fingerprint.
  string explain_fingerprint = 2;
  // ammount of variables in query.
  uint32 placeholders_count = 3;
  // digest_text - query signature. Query without values.
  string fingerprint = 4;

  //
  // Dimension Group.
  //

  // Service Name (can be several Services on one Node).
  string service_name = 10;
  // MongoDB or PostgreSQL database.
  // Several databases can't be combined in a single declarative query.
  string database = 11;
  // MySQL database or PostgreSQL schema.
  // Several schemas can be combined in a single declarative query.
  string schema = 12;
  // Tables or Collections list.
  repeated string tables = 13;
  // client user name.
  string username = 14;
  // client IP or hostname.
  string client_host = 15;

  //
  // Unified Labels Group.
  //

  // Node identifier
  string node_id = 20;
  // Node name
  string node_name = 21;
  // Node type
  string node_type = 22;
  // Machine identifier
  string machine_id = 23;
  // Container identifier
  string container_id = 24;
  // Container name
  string container_name = 25;
  // Node model
  string node_model = 26;
  // Region name
  string region = 27;
  // Availability zone
  string az = 28;
  // Service identifier
  string service_id = 29;
  // Type of service
  string service_type = 30;
  // Environment name
  string environment = 31;
  // Cluster name
  string cluster = 32;
  // Name of replication set
  string replication_set = 33;
  // Identifier of agent that collect and send metrics.
  string agent_id = 34;
  // Metrics source.
  inventory.v1.AgentType agent_type = 35;
  // Custom labels names:values.
  map<string, string> labels = 36;

  //
  // Period and Query Example Group.
  //

  // Time when collection of bucket started.
  uint32 period_start_unix_secs = 40;
  // Duration of bucket.
  uint32 period_length_secs = 41;
  // One of query example from set found in bucket.
  string example = 42;
  // Indicates if the query example is truncated.
  bool is_truncated = 43;
  ExampleType example_type = 44;
  // Metrics of query example in JSON format.
  string example_metrics = 45;

  //
  // Metrics.
  //

  // How many queries was with warnings in bucket.
  float num_queries_with_warnings = 50;
  // List of warnings: {code: count}.
  map<uint64, uint64> warnings = 51;
  // How many queries was with error in bucket.
  float num_queries_with_errors = 52;
  // List of errors: {code: count}.
  map<uint64, uint64> errors = 53;
  // Amount queries in this bucket.
  float num_queries = 54;
  // How many times query_time was found.
  float m_query_time_cnt = 55;
  // The statement execution time in seconds.
  float m_query_time_sum = 56;
  // Smallest value of query_time in bucket.
  float m_query_time_min = 57;
  // Biggest value of query_time in bucket.
  float m_query_time_max = 58;
  // 99 percentile of value of query_time in bucket.
  float m_query_time_p99 = 59;
  float m_lock_time_cnt = 60;
  // The time to acquire locks in seconds.
  float m_lock_time_sum = 61;
  float m_lock_time_min = 62;
  float m_lock_time_max = 63;
  float m_lock_time_p99 = 64;
  float m_rows_sent_cnt = 65;
  // The number of rows sent to the client.
  float m_rows_sent_sum = 66;
  float m_rows_sent_min = 67;
  float m_rows_sent_max = 68;
  float m_rows_sent_p99 = 69;
  float m_rows_examined_cnt = 70;
  // Number of rows scanned - SELECT.
  float m_rows_examined_sum = 71;
  float m_rows_examined_min = 72;
  float m_rows_examined_max = 73;
  float m_rows_examined_p99 = 74;
  float m_rows_affected_cnt = 75;
  // Number of rows changed - UPDATE, DELETE, INSERT.
  float m_rows_affected_sum = 76;
  float m_rows_affected_min = 77;
  float m_rows_affected_max = 78;
  float m_rows_affected_p99 = 79;
  float m_rows_read_cnt = 80;
  // The number of rows read from tables.
  float m_rows_read_sum = 81;
  float m_rows_read_min = 82;
  float m_rows_read_max = 83;
  float m_rows_read_p99 = 84;
  float m_merge_passes_cnt = 85;
  // The number of merge passes that the sort algorithm has had to do.
  float m_merge_passes_sum = 86;
  float m_merge_passes_min = 87;
  float m_merge_passes_max = 88;
  float m_merge_passes_p99 = 89;
  float m_innodb_io_r_ops_cnt = 90;
  // Counts the number of page read operations scheduled.
  float m_innodb_io_r_ops_sum = 91;
  float m_innodb_io_r_ops_min = 92;
  float m_innodb_io_r_ops_max = 93;
  float m_innodb_io_r_ops_p99 = 94;
  float m_innodb_io_r_bytes_cnt = 95;
  // Similar to innodb_IO_r_ops, but the unit is bytes.
  float m_innodb_io_r_bytes_sum = 96;
  float m_innodb_io_r_bytes_min = 97;
  float m_innodb_io_r_bytes_max = 98;
  float m_innodb_io_r_bytes_p99 = 99;
  float m_innodb_io_r_wait_cnt = 100;
  // Shows how long (in seconds) it took InnoDB to actually read the data from storage.
  float m_innodb_io_r_wait_sum = 101;
  float m_innodb_io_r_wait_min = 102;
  float m_innodb_io_r_wait_max = 103;
  float m_innodb_io_r_wait_p99 = 104;
  float m_innodb_rec_lock_wait_cnt = 105;
  // Shows how long (in seconds) the query waited for row locks.
  float m_innodb_rec_lock_wait_sum = 106;
  float m_innodb_rec_lock_wait_min = 107;
  float m_innodb_rec_lock_wait_max = 108;
  float m_innodb_rec_lock_wait_p99 = 109;
  float m_innodb_queue_wait_cnt = 110;
  // Shows how long (in seconds) the query spent either waiting to enter the InnoDB queue or inside that queue waiting for execution.
  float m_innodb_queue_wait_sum = 111;
  float m_innodb_queue_wait_min = 112;
  float m_innodb_queue_wait_max = 113;
  float m_innodb_queue_wait_p99 = 114;
  float m_innodb_pages_distinct_cnt = 115;
  // Counts approximately the number of unique pages the query accessed.
  float m_innodb_pages_distinct_sum = 116;
  float m_innodb_pages_distinct_min = 117;
  float m_innodb_pages_distinct_max = 118;
  float m_innodb_pages_distinct_p99 = 119;
  float m_query_length_cnt = 120;
  // Shows how long the query is.
  float m_query_length_sum = 121;
  float m_query_length_min = 122;
  float m_query_length_max = 123;
  float m_query_length_p99 = 124;
  float m_bytes_sent_cnt = 125;
  // The number of bytes sent to all clients.
  float m_bytes_sent_sum = 126;
  float m_bytes_sent_min = 127;
  float m_bytes_sent_max = 128;
  float m_bytes_sent_p99 = 129;
  float m_tmp_tables_cnt = 130;
  // Number of temporary tables created on memory for the query.
  float m_tmp_tables_sum = 131;
  float m_tmp_tables_min = 132;
  float m_tmp_tables_max = 133;
  float m_tmp_tables_p99 = 134;
  float m_tmp_disk_tables_cnt = 135;
  // Number of temporary tables created on disk for the query.
  float m_tmp_disk_tables_sum = 136;
  float m_tmp_disk_tables_min = 137;
  float m_tmp_disk_tables_max = 138;
  float m_tmp_disk_tables_p99 = 139;
  float m_tmp_table_sizes_cnt = 140;
  // Total Size in bytes for all temporary tables used in the query.
  float m_tmp_table_sizes_sum = 141;
  float m_tmp_table_sizes_min = 142;
  float m_tmp_table_sizes_max = 143;
  float m_tmp_table_sizes_p99 = 144;

  //
  // Boolean metrics:
  // - *_cnt - how many times this matric was met.
  // - *_sum - how many times this matric was true.
  //

  float m_qc_hit_cnt = 150;
  // Query Cache hits.
  float m_qc_hit_sum = 151;
  float m_full_scan_cnt = 152;
  // The query performed a full table scan.
  float m_full_scan_sum = 153;
  float m_full_join_cnt = 154;
  // The query performed a full join (a join without indexes).
  float m_full_join_sum = 155;
  float m_tmp_table_cnt = 156;
  // The query created an implicit internal temporary table.
  float m_tmp_table_sum = 157;
  float m_tmp_table_on_disk_cnt = 158;
  // The querys temporary table was stored on disk.
  float m_tmp_table_on_disk_sum = 159;
  float m_filesort_cnt = 160;
  // The query used a filesort.
  float m_filesort_sum = 161;
  float m_filesort_on_disk_cnt = 162;
  // The filesort was performed on disk.
  float m_filesort_on_disk_sum = 163;
  float m_select_full_range_join_cnt = 164;
  // The number of joins that used a range search on a reference table.
  float m_select_full_range_join_sum = 165;
  float m_select_range_cnt = 166;
  // The number of joins that used ranges on the first table.
  float m_select_range_sum = 167;
  float m_select_range_check_cnt = 168;
  // The number of joins without keys that check for key usage after each row.
  float m_select_range_check_sum = 169;
  float m_sort_range_cnt = 170;
  // The number of sorts that were done using ranges.
  float m_sort_range_sum = 171;
  float m_sort_rows_cnt = 172;
  // The number of sorted rows.
  float m_sort_rows_sum = 173;
  float m_sort_scan_cnt = 174;
  // The number of sorts that were done by scanning the table.
  float m_sort_scan_sum = 175;
  float m_no_index_used_cnt = 176;
  // The number of queries without index.
  float m_no_index_used_sum = 177;
  float m_no_good_index_used_cnt = 178;
  // The number of queries without good index.
  float m_no_good_index_used_sum = 179;

  //
  // MongoDB metrics.
  //

  float m_docs_returned_cnt = 190;
  // The number of returned documents.
  float m_docs_returned_sum = 191;
  float m_docs_returned_min = 192;
  float m_docs_returned_max = 193;
  float m_docs_returned_p99 = 147;
  float m_response_length_cnt = 195;
  // The response length of the query result in bytes.
  float m_response_length_sum = 196;
  float m_response_length_min = 197;
  float m_response_length_max = 198;
  float m_response_length_p99 = 199;
  float m_docs_scanned_cnt = 200;
  // The number of scanned documents.
  float m_docs_scanned_sum = 201;
  float m_docs_scanned_min = 202;
  float m_docs_scanned_max = 203;
  float m_docs_scanned_p99 = 204;
  //
  // PostgreSQL metrics.
  //

  float m_shared_blks_hit_cnt = 210;
  // Total number of shared block cache hits by the statement.
  float m_shared_blks_hit_sum = 211;
  float m_shared_blks_read_cnt = 212;
  // Total number of shared blocks read by the statement.
  float m_shared_blks_read_sum = 213;
  float m_shared_blks_dirtied_cnt = 214;
  // Total number of shared blocks dirtied by the statement.
  float m_shared_blks_dirtied_sum = 215;
  float m_shared_blks_written_cnt = 216;
  // Total number of shared blocks written by the statement.
  float m_shared_blks_written_sum = 217;
  float m_local_blks_hit_cnt = 218;
  // Total number of local block cache hits by the statement.
  float m_local_blks_hit_sum = 219;
  float m_local_blks_read_cnt = 220;
  // Total number of local blocks read by the statement.
  float m_local_blks_read_sum = 221;
  float m_local_blks_dirtied_cnt = 222;
  // Total number of local blocks dirtied by the statement.
  float m_local_blks_dirtied_sum = 223;
  float m_local_blks_written_cnt = 224;
  // Total number of local blocks written by the statement.
  float m_local_blks_written_sum = 225;
  float m_temp_blks_read_cnt = 226;
  // Total number of temp blocks read by the statement.
  float m_temp_blks_read_sum = 227;
  float m_temp_blks_written_cnt = 228;
  // Total number of temp blocks written by the statement.
  float m_temp_blks_written_sum = 229;
  float m_blk_read_time_cnt = 230;
  // Total time the statement spent reading blocks, in milliseconds (if track_io_timing is enabled, otherwise zero).
  float m_blk_read_time_sum = 231;
  float m_blk_write_time_cnt = 232;
  // Total time the statement spent writing blocks, in milliseconds (if track_io_timing is enabled, otherwise zero).
  float m_blk_write_time_sum = 233;
  float m_cpu_user_time_cnt = 234;
  // Total time user spent in query.
  float m_cpu_user_time_sum = 235;
  float m_cpu_sys_time_cnt = 236;
  // Total time system spent in query.
  float m_cpu_sys_time_sum = 237;
  // Type of SQL command.
  string cmd_type = 238;

  //
  // pg_stat_monitor 0.9 metrics
  //

  // Total number of planned calls.
  float m_plans_calls_sum = 250;
  float m_plans_calls_cnt = 251;
  // Total number of WAL (Write-ahead logging) records.
  float m_wal_records_sum = 252;
  float m_wal_records_cnt = 253;
  // Total number of FPI (full page images) in WAL (Write-ahead logging) records.
  float m_wal_fpi_sum = 254;
  float m_wal_fpi_cnt = 255;
  // Total bytes of WAL (Write-ahead logging) records.
  float m_wal_bytes_sum = 256;
  float m_wal_bytes_cnt = 257;
  // Sum, count, min, max of plan time.
  float m_plan_time_sum = 258;
  float m_plan_time_cnt = 259;
  float m_plan_time_min = 260;
  float m_plan_time_max = 261;
  // Metrics skipped due to different bucket_time in pg_stat_monitor (17min in PMM, 5min in pg_stat_monitor):
  // min_time, max_time, mean_time
  // plan_mean_time
  // stddev_time
  // Other metrics skipped (empty values, codes):
  // cmd_type_text, elevel, sqlcode, message, state_code, state
  string top_queryid = 263;
  string top_query = 264;
  string application_name = 265;
  string planid = 266;
  string query_plan = 267;
  repeated string histogram_items = 268;
}

message CollectResponse {}
