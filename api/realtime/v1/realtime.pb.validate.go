// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: realtime/v1/realtime.proto

package realtimev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RealTimeQueryData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RealTimeQueryData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealTimeQueryData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealTimeQueryDataMultiError, or nil if none found.
func (m *RealTimeQueryData) ValidateAll() error {
	return m.validate(true)
}

func (m *RealTimeQueryData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QueryId

	// no validation rules for QueryText

	// no validation rules for Fingerprint

	// no validation rules for Database

	// no validation rules for ClientHost

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RealTimeQueryDataValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RealTimeQueryDataValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RealTimeQueryDataValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for CurrentExecutionTime

	if all {
		switch v := interface{}(m.GetMongodb()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RealTimeQueryDataValidationError{
					field:  "Mongodb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RealTimeQueryDataValidationError{
					field:  "Mongodb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMongodb()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RealTimeQueryDataValidationError{
				field:  "Mongodb",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServiceId

	// no validation rules for ServiceName

	// no validation rules for NodeId

	// no validation rules for NodeName

	// no validation rules for Labels

	if len(errors) > 0 {
		return RealTimeQueryDataMultiError(errors)
	}

	return nil
}

// RealTimeQueryDataMultiError is an error wrapping multiple validation errors
// returned by RealTimeQueryData.ValidateAll() if the designated constraints
// aren't met.
type RealTimeQueryDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealTimeQueryDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealTimeQueryDataMultiError) AllErrors() []error { return m }

// RealTimeQueryDataValidationError is the validation error returned by
// RealTimeQueryData.Validate if the designated constraints aren't met.
type RealTimeQueryDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealTimeQueryDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealTimeQueryDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealTimeQueryDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealTimeQueryDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealTimeQueryDataValidationError) ErrorName() string {
	return "RealTimeQueryDataValidationError"
}

// Error satisfies the builtin error interface
func (e RealTimeQueryDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealTimeQueryData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealTimeQueryDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealTimeQueryDataValidationError{}

// Validate checks the field values on MongoDBFields with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MongoDBFields) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MongoDBFields with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MongoDBFieldsMultiError, or
// nil if none found.
func (m *MongoDBFields) ValidateAll() error {
	return m.validate(true)
}

func (m *MongoDBFields) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Opid

	// no validation rules for SecsRunning

	// no validation rules for OperationType

	// no validation rules for Namespace

	// no validation rules for PlanSummary

	// no validation rules for Blocking

	// no validation rules for CurrentOpRaw

	if len(errors) > 0 {
		return MongoDBFieldsMultiError(errors)
	}

	return nil
}

// MongoDBFieldsMultiError is an error wrapping multiple validation errors
// returned by MongoDBFields.ValidateAll() if the designated constraints
// aren't met.
type MongoDBFieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MongoDBFieldsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MongoDBFieldsMultiError) AllErrors() []error { return m }

// MongoDBFieldsValidationError is the validation error returned by
// MongoDBFields.Validate if the designated constraints aren't met.
type MongoDBFieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MongoDBFieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MongoDBFieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MongoDBFieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MongoDBFieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MongoDBFieldsValidationError) ErrorName() string { return "MongoDBFieldsValidationError" }

// Error satisfies the builtin error interface
func (e MongoDBFieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMongoDBFields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MongoDBFieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MongoDBFieldsValidationError{}

// Validate checks the field values on RealTimeAnalyticsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RealTimeAnalyticsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealTimeAnalyticsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealTimeAnalyticsRequestMultiError, or nil if none found.
func (m *RealTimeAnalyticsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RealTimeAnalyticsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetQueries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RealTimeAnalyticsRequestValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RealTimeAnalyticsRequestValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RealTimeAnalyticsRequestValidationError{
					field:  fmt.Sprintf("Queries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCollectionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RealTimeAnalyticsRequestValidationError{
					field:  "CollectionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RealTimeAnalyticsRequestValidationError{
					field:  "CollectionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCollectionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RealTimeAnalyticsRequestValidationError{
				field:  "CollectionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RealTimeAnalyticsRequestMultiError(errors)
	}

	return nil
}

// RealTimeAnalyticsRequestMultiError is an error wrapping multiple validation
// errors returned by RealTimeAnalyticsRequest.ValidateAll() if the designated
// constraints aren't met.
type RealTimeAnalyticsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealTimeAnalyticsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealTimeAnalyticsRequestMultiError) AllErrors() []error { return m }

// RealTimeAnalyticsRequestValidationError is the validation error returned by
// RealTimeAnalyticsRequest.Validate if the designated constraints aren't met.
type RealTimeAnalyticsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealTimeAnalyticsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealTimeAnalyticsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealTimeAnalyticsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealTimeAnalyticsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealTimeAnalyticsRequestValidationError) ErrorName() string {
	return "RealTimeAnalyticsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RealTimeAnalyticsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealTimeAnalyticsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealTimeAnalyticsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealTimeAnalyticsRequestValidationError{}

// Validate checks the field values on RealTimeAnalyticsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RealTimeAnalyticsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealTimeAnalyticsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealTimeAnalyticsResponseMultiError, or nil if none found.
func (m *RealTimeAnalyticsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RealTimeAnalyticsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RealTimeAnalyticsResponseMultiError(errors)
	}

	return nil
}

// RealTimeAnalyticsResponseMultiError is an error wrapping multiple validation
// errors returned by RealTimeAnalyticsResponse.ValidateAll() if the
// designated constraints aren't met.
type RealTimeAnalyticsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealTimeAnalyticsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealTimeAnalyticsResponseMultiError) AllErrors() []error { return m }

// RealTimeAnalyticsResponseValidationError is the validation error returned by
// RealTimeAnalyticsResponse.Validate if the designated constraints aren't met.
type RealTimeAnalyticsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealTimeAnalyticsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealTimeAnalyticsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealTimeAnalyticsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealTimeAnalyticsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealTimeAnalyticsResponseValidationError) ErrorName() string {
	return "RealTimeAnalyticsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RealTimeAnalyticsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealTimeAnalyticsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealTimeAnalyticsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealTimeAnalyticsResponseValidationError{}

// Validate checks the field values on RealTimeDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RealTimeDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealTimeDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealTimeDataRequestMultiError, or nil if none found.
func (m *RealTimeDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RealTimeDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for IncludeHistory

	if len(errors) > 0 {
		return RealTimeDataRequestMultiError(errors)
	}

	return nil
}

// RealTimeDataRequestMultiError is an error wrapping multiple validation
// errors returned by RealTimeDataRequest.ValidateAll() if the designated
// constraints aren't met.
type RealTimeDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealTimeDataRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealTimeDataRequestMultiError) AllErrors() []error { return m }

// RealTimeDataRequestValidationError is the validation error returned by
// RealTimeDataRequest.Validate if the designated constraints aren't met.
type RealTimeDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealTimeDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealTimeDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealTimeDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealTimeDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealTimeDataRequestValidationError) ErrorName() string {
	return "RealTimeDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RealTimeDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealTimeDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealTimeDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealTimeDataRequestValidationError{}

// Validate checks the field values on RealTimeDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RealTimeDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealTimeDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RealTimeDataResponseMultiError, or nil if none found.
func (m *RealTimeDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RealTimeDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetQueries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RealTimeDataResponseValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RealTimeDataResponseValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RealTimeDataResponseValidationError{
					field:  fmt.Sprintf("Queries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	// no validation rules for HasMore

	if len(errors) > 0 {
		return RealTimeDataResponseMultiError(errors)
	}

	return nil
}

// RealTimeDataResponseMultiError is an error wrapping multiple validation
// errors returned by RealTimeDataResponse.ValidateAll() if the designated
// constraints aren't met.
type RealTimeDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealTimeDataResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealTimeDataResponseMultiError) AllErrors() []error { return m }

// RealTimeDataResponseValidationError is the validation error returned by
// RealTimeDataResponse.Validate if the designated constraints aren't met.
type RealTimeDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealTimeDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealTimeDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealTimeDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealTimeDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealTimeDataResponseValidationError) ErrorName() string {
	return "RealTimeDataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RealTimeDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealTimeDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealTimeDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealTimeDataResponseValidationError{}

// Validate checks the field values on EnableRealTimeAnalyticsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnableRealTimeAnalyticsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableRealTimeAnalyticsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EnableRealTimeAnalyticsRequestMultiError, or nil if none found.
func (m *EnableRealTimeAnalyticsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableRealTimeAnalyticsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceId

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnableRealTimeAnalyticsRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnableRealTimeAnalyticsRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnableRealTimeAnalyticsRequestValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnableRealTimeAnalyticsRequestMultiError(errors)
	}

	return nil
}

// EnableRealTimeAnalyticsRequestMultiError is an error wrapping multiple
// validation errors returned by EnableRealTimeAnalyticsRequest.ValidateAll()
// if the designated constraints aren't met.
type EnableRealTimeAnalyticsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableRealTimeAnalyticsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableRealTimeAnalyticsRequestMultiError) AllErrors() []error { return m }

// EnableRealTimeAnalyticsRequestValidationError is the validation error
// returned by EnableRealTimeAnalyticsRequest.Validate if the designated
// constraints aren't met.
type EnableRealTimeAnalyticsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableRealTimeAnalyticsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableRealTimeAnalyticsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableRealTimeAnalyticsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableRealTimeAnalyticsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableRealTimeAnalyticsRequestValidationError) ErrorName() string {
	return "EnableRealTimeAnalyticsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EnableRealTimeAnalyticsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableRealTimeAnalyticsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableRealTimeAnalyticsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableRealTimeAnalyticsRequestValidationError{}

// Validate checks the field values on DisableRealTimeAnalyticsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DisableRealTimeAnalyticsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisableRealTimeAnalyticsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DisableRealTimeAnalyticsRequestMultiError, or nil if none found.
func (m *DisableRealTimeAnalyticsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DisableRealTimeAnalyticsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceId

	if len(errors) > 0 {
		return DisableRealTimeAnalyticsRequestMultiError(errors)
	}

	return nil
}

// DisableRealTimeAnalyticsRequestMultiError is an error wrapping multiple
// validation errors returned by DisableRealTimeAnalyticsRequest.ValidateAll()
// if the designated constraints aren't met.
type DisableRealTimeAnalyticsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisableRealTimeAnalyticsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisableRealTimeAnalyticsRequestMultiError) AllErrors() []error { return m }

// DisableRealTimeAnalyticsRequestValidationError is the validation error
// returned by DisableRealTimeAnalyticsRequest.Validate if the designated
// constraints aren't met.
type DisableRealTimeAnalyticsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisableRealTimeAnalyticsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisableRealTimeAnalyticsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisableRealTimeAnalyticsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisableRealTimeAnalyticsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisableRealTimeAnalyticsRequestValidationError) ErrorName() string {
	return "DisableRealTimeAnalyticsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DisableRealTimeAnalyticsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisableRealTimeAnalyticsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisableRealTimeAnalyticsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisableRealTimeAnalyticsRequestValidationError{}

// Validate checks the field values on RealTimeConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RealTimeConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RealTimeConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RealTimeConfigMultiError,
// or nil if none found.
func (m *RealTimeConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RealTimeConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionIntervalSeconds

	// no validation rules for DisableExamples

	if len(errors) > 0 {
		return RealTimeConfigMultiError(errors)
	}

	return nil
}

// RealTimeConfigMultiError is an error wrapping multiple validation errors
// returned by RealTimeConfig.ValidateAll() if the designated constraints
// aren't met.
type RealTimeConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RealTimeConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RealTimeConfigMultiError) AllErrors() []error { return m }

// RealTimeConfigValidationError is the validation error returned by
// RealTimeConfig.Validate if the designated constraints aren't met.
type RealTimeConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RealTimeConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RealTimeConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RealTimeConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RealTimeConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RealTimeConfigValidationError) ErrorName() string { return "RealTimeConfigValidationError" }

// Error satisfies the builtin error interface
func (e RealTimeConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRealTimeConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RealTimeConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RealTimeConfigValidationError{}

// Validate checks the field values on ConfigResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigResponseMultiError,
// or nil if none found.
func (m *ConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if len(errors) > 0 {
		return ConfigResponseMultiError(errors)
	}

	return nil
}

// ConfigResponseMultiError is an error wrapping multiple validation errors
// returned by ConfigResponse.ValidateAll() if the designated constraints
// aren't met.
type ConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigResponseMultiError) AllErrors() []error { return m }

// ConfigResponseValidationError is the validation error returned by
// ConfigResponse.Validate if the designated constraints aren't met.
type ConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigResponseValidationError) ErrorName() string { return "ConfigResponseValidationError" }

// Error satisfies the builtin error interface
func (e ConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigResponseValidationError{}
