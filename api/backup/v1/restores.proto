syntax = "proto3";

package backup.v1;

import "backup/v1/common.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "protoc-gen-openapiv2/options/annotations.proto";
import "validate/validate.proto";

// RestoreStatus shows the current status of execution of restore.
enum RestoreStatus {
  RESTORE_STATUS_UNSPECIFIED = 0;
  RESTORE_STATUS_IN_PROGRESS = 1;
  RESTORE_STATUS_SUCCESS = 2;
  RESTORE_STATUS_ERROR = 3;
}

// RestoreHistoryItem represents single backup restore item.
message RestoreHistoryItem {
  // Machine-readable restore id.
  string restore_id = 1;
  // ID of the artifact used for restore.
  string artifact_id = 2;
  // Artifact name used for restore.
  string name = 3;
  // Database vendor e.g. PostgreSQL, MongoDB, MySQL.
  string vendor = 4;
  // Machine-readable location ID.
  string location_id = 5;
  // Location name.
  string location_name = 6;
  // Machine-readable service ID.
  string service_id = 7;
  // Service name.
  string service_name = 8;
  // Backup data model.
  DataModel data_model = 9;
  // Restore status.
  RestoreStatus status = 10;
  // Restore start time.
  google.protobuf.Timestamp started_at = 11;
  // Restore finish time.
  google.protobuf.Timestamp finished_at = 12;
  // PITR timestamp is filled for PITR restores, empty otherwise.
  google.protobuf.Timestamp pitr_timestamp = 13;
}

message ListRestoresRequest {}

message ListRestoresResponse {
  repeated RestoreHistoryItem items = 1;
}

message RestoreServiceGetLogsRequest {
  string restore_id = 1 [(validate.rules).string.min_len = 1];
  uint32 offset = 2;
  uint32 limit = 3;
}

message RestoreServiceGetLogsResponse {
  repeated LogChunk logs = 1;
  bool end = 2;
}

message RestoreBackupRequest {
  // Service identifier where backup should be restored.
  string service_id = 1 [(validate.rules).string.min_len = 1];
  // Artifact id to restore.
  string artifact_id = 2 [(validate.rules).string.min_len = 1];
  // Timestamp of PITR to restore to
  google.protobuf.Timestamp pitr_timestamp = 3;
}

message RestoreBackupResponse {
  // Unique restore identifier.
  string restore_id = 1;
}

// RestoreService provides public methods for managing backup restore history.
service RestoreService {
  // ListRestores returns a list of all backup restore history items.
  rpc ListRestores(ListRestoresRequest) returns (ListRestoresResponse) {
    option (google.api.http) = {get: "/v1/backups/restores"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "List Restore History"
      description: "List all backup restore history items"
    };
  }
  // GetLogs returns logs from the underlying tools for a restore job.
  rpc GetLogs(RestoreServiceGetLogsRequest) returns (RestoreServiceGetLogsResponse) {
    option (google.api.http) = {get: "/v1/backups/restores/{restore_id}/logs"};
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Get Logs"
      description: "Get logs from the underlying tools for a restore job"
    };
  }
  // RestoreBackup requests the backup restore.
  rpc RestoreBackup(RestoreBackupRequest) returns (RestoreBackupResponse) {
    option (google.api.http) = {
      post: "/v1/backups/restores:start"
      body: "*"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Restore from a Backup"
      description: "Could return the Error message in the details containing specific ErrorCode indicating failure reason:\nERROR_CODE_XTRABACKUP_NOT_INSTALLED - xtrabackup is not installed on the service\nERROR_CODE_INVALID_XTRABACKUP - different versions of xtrabackup and xbcloud\nERROR_CODE_INCOMPATIBLE_XTRABACKUP - xtrabackup is not compatible with MySQL for taking a backup\nERROR_CODE_INCOMPATIBLE_TARGET_MYSQL - target MySQL version is not compatible with the artifact for performing a restore of the backup"
    };
  }
}
