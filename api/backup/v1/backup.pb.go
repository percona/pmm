// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: backup/v1/backup.proto

package backupv1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"

	v1 "github.com/percona/pmm/api/inventory/v1"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type StartBackupRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Service identifier.
	ServiceId string `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// Machine-readable location ID.
	LocationId string `protobuf:"bytes,2,opt,name=location_id,json=locationId,proto3" json:"location_id,omitempty"`
	// If empty then name is auto-generated.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Human-readable description.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Delay between each retry. Should have a suffix in JSON: 1s, 1m, 1h.
	RetryInterval *durationpb.Duration `protobuf:"bytes,5,opt,name=retry_interval,json=retryInterval,proto3" json:"retry_interval,omitempty"`
	// How many times to retry a failed backup before giving up.
	Retries uint32 `protobuf:"varint,6,opt,name=retries,proto3" json:"retries,omitempty"`
	// DataModel represents the data model used for the backup.
	DataModel DataModel `protobuf:"varint,7,opt,name=data_model,json=dataModel,proto3,enum=backup.v1.DataModel" json:"data_model,omitempty"`
	// Folder on storage for artifact.
	Folder string `protobuf:"bytes,8,opt,name=folder,proto3" json:"folder,omitempty"`
	// Compression
	Compression   BackupCompression `protobuf:"varint,9,opt,name=compression,proto3,enum=backup.v1.BackupCompression" json:"compression,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartBackupRequest) Reset() {
	*x = StartBackupRequest{}
	mi := &file_backup_v1_backup_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartBackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartBackupRequest) ProtoMessage() {}

func (x *StartBackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartBackupRequest.ProtoReflect.Descriptor instead.
func (*StartBackupRequest) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{0}
}

func (x *StartBackupRequest) GetServiceId() string {
	if x != nil {
		return x.ServiceId
	}
	return ""
}

func (x *StartBackupRequest) GetLocationId() string {
	if x != nil {
		return x.LocationId
	}
	return ""
}

func (x *StartBackupRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StartBackupRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *StartBackupRequest) GetRetryInterval() *durationpb.Duration {
	if x != nil {
		return x.RetryInterval
	}
	return nil
}

func (x *StartBackupRequest) GetRetries() uint32 {
	if x != nil {
		return x.Retries
	}
	return 0
}

func (x *StartBackupRequest) GetDataModel() DataModel {
	if x != nil {
		return x.DataModel
	}
	return DataModel_DATA_MODEL_UNSPECIFIED
}

func (x *StartBackupRequest) GetFolder() string {
	if x != nil {
		return x.Folder
	}
	return ""
}

func (x *StartBackupRequest) GetCompression() BackupCompression {
	if x != nil {
		return x.Compression
	}
	return BackupCompression_BACKUP_COMPRESSION_UNSPECIFIED
}

type StartBackupResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier.
	ArtifactId    string `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartBackupResponse) Reset() {
	*x = StartBackupResponse{}
	mi := &file_backup_v1_backup_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartBackupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartBackupResponse) ProtoMessage() {}

func (x *StartBackupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartBackupResponse.ProtoReflect.Descriptor instead.
func (*StartBackupResponse) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{1}
}

func (x *StartBackupResponse) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

type ListArtifactCompatibleServicesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Artifact id used to determine restore compatibility.
	ArtifactId    string `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListArtifactCompatibleServicesRequest) Reset() {
	*x = ListArtifactCompatibleServicesRequest{}
	mi := &file_backup_v1_backup_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListArtifactCompatibleServicesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListArtifactCompatibleServicesRequest) ProtoMessage() {}

func (x *ListArtifactCompatibleServicesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListArtifactCompatibleServicesRequest.ProtoReflect.Descriptor instead.
func (*ListArtifactCompatibleServicesRequest) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{2}
}

func (x *ListArtifactCompatibleServicesRequest) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

type ListArtifactCompatibleServicesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mysql         []*v1.MySQLService     `protobuf:"bytes,1,rep,name=mysql,proto3" json:"mysql,omitempty"`
	Mongodb       []*v1.MongoDBService   `protobuf:"bytes,2,rep,name=mongodb,proto3" json:"mongodb,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListArtifactCompatibleServicesResponse) Reset() {
	*x = ListArtifactCompatibleServicesResponse{}
	mi := &file_backup_v1_backup_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListArtifactCompatibleServicesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListArtifactCompatibleServicesResponse) ProtoMessage() {}

func (x *ListArtifactCompatibleServicesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListArtifactCompatibleServicesResponse.ProtoReflect.Descriptor instead.
func (*ListArtifactCompatibleServicesResponse) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{3}
}

func (x *ListArtifactCompatibleServicesResponse) GetMysql() []*v1.MySQLService {
	if x != nil {
		return x.Mysql
	}
	return nil
}

func (x *ListArtifactCompatibleServicesResponse) GetMongodb() []*v1.MongoDBService {
	if x != nil {
		return x.Mongodb
	}
	return nil
}

// ScheduledBackup represents scheduled task for backup.
type ScheduledBackup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Machine-readable ID.
	ScheduledBackupId string `protobuf:"bytes,1,opt,name=scheduled_backup_id,json=scheduledBackupId,proto3" json:"scheduled_backup_id,omitempty"`
	// Machine-readable service ID.
	ServiceId string `protobuf:"bytes,2,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// Service name.
	ServiceName string `protobuf:"bytes,3,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// Machine-readable location ID.
	LocationId string `protobuf:"bytes,4,opt,name=location_id,json=locationId,proto3" json:"location_id,omitempty"`
	// Location name.
	LocationName string `protobuf:"bytes,5,opt,name=location_name,json=locationName,proto3" json:"location_name,omitempty"`
	// Folder on storage for artifact.
	Folder string `protobuf:"bytes,6,opt,name=folder,proto3" json:"folder,omitempty"`
	// How often backup will be run in cron format.
	CronExpression string `protobuf:"bytes,7,opt,name=cron_expression,json=cronExpression,proto3" json:"cron_expression,omitempty"`
	// First backup wouldn't happen before this time.
	StartTime *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Artifact name.
	Name string `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	// Description.
	Description string `protobuf:"bytes,10,opt,name=description,proto3" json:"description,omitempty"`
	// If scheduling is enabled.
	Enabled bool `protobuf:"varint,11,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// How many times to retry a failed backup before giving up.
	Retries uint32 `protobuf:"varint,12,opt,name=retries,proto3" json:"retries,omitempty"`
	// Delay between each retry. Should have a suffix in JSON: 2s, 1m, 1h.
	RetryInterval *durationpb.Duration `protobuf:"bytes,13,opt,name=retry_interval,json=retryInterval,proto3" json:"retry_interval,omitempty"`
	// Backup data model (physical or logical).
	DataModel DataModel `protobuf:"varint,14,opt,name=data_model,json=dataModel,proto3,enum=backup.v1.DataModel" json:"data_model,omitempty"`
	// Backup mode.
	Mode BackupMode `protobuf:"varint,15,opt,name=mode,proto3,enum=backup.v1.BackupMode" json:"mode,omitempty"`
	// Database vendor e.g. PostgreSQL, MongoDB, MySQL.
	Vendor string `protobuf:"bytes,16,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// Last run.
	LastRun *timestamppb.Timestamp `protobuf:"bytes,17,opt,name=last_run,json=lastRun,proto3" json:"last_run,omitempty"`
	// Next run.
	NextRun *timestamppb.Timestamp `protobuf:"bytes,18,opt,name=next_run,json=nextRun,proto3" json:"next_run,omitempty"`
	// How many artifacts keep. 0 - unlimited.
	Retention uint32 `protobuf:"varint,19,opt,name=retention,proto3" json:"retention,omitempty"`
	// Compression
	Compression   BackupCompression `protobuf:"varint,20,opt,name=compression,proto3,enum=backup.v1.BackupCompression" json:"compression,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScheduledBackup) Reset() {
	*x = ScheduledBackup{}
	mi := &file_backup_v1_backup_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduledBackup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduledBackup) ProtoMessage() {}

func (x *ScheduledBackup) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduledBackup.ProtoReflect.Descriptor instead.
func (*ScheduledBackup) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{4}
}

func (x *ScheduledBackup) GetScheduledBackupId() string {
	if x != nil {
		return x.ScheduledBackupId
	}
	return ""
}

func (x *ScheduledBackup) GetServiceId() string {
	if x != nil {
		return x.ServiceId
	}
	return ""
}

func (x *ScheduledBackup) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *ScheduledBackup) GetLocationId() string {
	if x != nil {
		return x.LocationId
	}
	return ""
}

func (x *ScheduledBackup) GetLocationName() string {
	if x != nil {
		return x.LocationName
	}
	return ""
}

func (x *ScheduledBackup) GetFolder() string {
	if x != nil {
		return x.Folder
	}
	return ""
}

func (x *ScheduledBackup) GetCronExpression() string {
	if x != nil {
		return x.CronExpression
	}
	return ""
}

func (x *ScheduledBackup) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ScheduledBackup) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ScheduledBackup) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ScheduledBackup) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ScheduledBackup) GetRetries() uint32 {
	if x != nil {
		return x.Retries
	}
	return 0
}

func (x *ScheduledBackup) GetRetryInterval() *durationpb.Duration {
	if x != nil {
		return x.RetryInterval
	}
	return nil
}

func (x *ScheduledBackup) GetDataModel() DataModel {
	if x != nil {
		return x.DataModel
	}
	return DataModel_DATA_MODEL_UNSPECIFIED
}

func (x *ScheduledBackup) GetMode() BackupMode {
	if x != nil {
		return x.Mode
	}
	return BackupMode_BACKUP_MODE_UNSPECIFIED
}

func (x *ScheduledBackup) GetVendor() string {
	if x != nil {
		return x.Vendor
	}
	return ""
}

func (x *ScheduledBackup) GetLastRun() *timestamppb.Timestamp {
	if x != nil {
		return x.LastRun
	}
	return nil
}

func (x *ScheduledBackup) GetNextRun() *timestamppb.Timestamp {
	if x != nil {
		return x.NextRun
	}
	return nil
}

func (x *ScheduledBackup) GetRetention() uint32 {
	if x != nil {
		return x.Retention
	}
	return 0
}

func (x *ScheduledBackup) GetCompression() BackupCompression {
	if x != nil {
		return x.Compression
	}
	return BackupCompression_BACKUP_COMPRESSION_UNSPECIFIED
}

type ScheduleBackupRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Service identifier where backup should be performed.
	ServiceId string `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// Machine-readable location ID.
	LocationId string `protobuf:"bytes,2,opt,name=location_id,json=locationId,proto3" json:"location_id,omitempty"`
	// How often backup should be run in cron format.
	// Folder on storage for artifact.
	Folder         string `protobuf:"bytes,3,opt,name=folder,proto3" json:"folder,omitempty"`
	CronExpression string `protobuf:"bytes,4,opt,name=cron_expression,json=cronExpression,proto3" json:"cron_expression,omitempty"`
	// First backup wouldn't happen before this time.
	StartTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Name of backup.
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// Human-readable description.
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	// If scheduling is enabled.
	Enabled bool `protobuf:"varint,8,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// How many times to retry a failed backup before giving up.
	Retries uint32 `protobuf:"varint,9,opt,name=retries,proto3" json:"retries,omitempty"`
	// Delay between each retry. Should have a suffix in JSON: 1s, 1m, 1h.
	RetryInterval *durationpb.Duration `protobuf:"bytes,10,opt,name=retry_interval,json=retryInterval,proto3" json:"retry_interval,omitempty"`
	// Backup mode.
	Mode BackupMode `protobuf:"varint,11,opt,name=mode,proto3,enum=backup.v1.BackupMode" json:"mode,omitempty"`
	// Backup data model (physical or logical).
	DataModel DataModel `protobuf:"varint,12,opt,name=data_model,json=dataModel,proto3,enum=backup.v1.DataModel" json:"data_model,omitempty"`
	// How many artifacts keep. 0 - unlimited.
	Retention uint32 `protobuf:"varint,13,opt,name=retention,proto3" json:"retention,omitempty"`
	// Compression
	Compression   BackupCompression `protobuf:"varint,14,opt,name=compression,proto3,enum=backup.v1.BackupCompression" json:"compression,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScheduleBackupRequest) Reset() {
	*x = ScheduleBackupRequest{}
	mi := &file_backup_v1_backup_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleBackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleBackupRequest) ProtoMessage() {}

func (x *ScheduleBackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleBackupRequest.ProtoReflect.Descriptor instead.
func (*ScheduleBackupRequest) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{5}
}

func (x *ScheduleBackupRequest) GetServiceId() string {
	if x != nil {
		return x.ServiceId
	}
	return ""
}

func (x *ScheduleBackupRequest) GetLocationId() string {
	if x != nil {
		return x.LocationId
	}
	return ""
}

func (x *ScheduleBackupRequest) GetFolder() string {
	if x != nil {
		return x.Folder
	}
	return ""
}

func (x *ScheduleBackupRequest) GetCronExpression() string {
	if x != nil {
		return x.CronExpression
	}
	return ""
}

func (x *ScheduleBackupRequest) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ScheduleBackupRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ScheduleBackupRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ScheduleBackupRequest) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ScheduleBackupRequest) GetRetries() uint32 {
	if x != nil {
		return x.Retries
	}
	return 0
}

func (x *ScheduleBackupRequest) GetRetryInterval() *durationpb.Duration {
	if x != nil {
		return x.RetryInterval
	}
	return nil
}

func (x *ScheduleBackupRequest) GetMode() BackupMode {
	if x != nil {
		return x.Mode
	}
	return BackupMode_BACKUP_MODE_UNSPECIFIED
}

func (x *ScheduleBackupRequest) GetDataModel() DataModel {
	if x != nil {
		return x.DataModel
	}
	return DataModel_DATA_MODEL_UNSPECIFIED
}

func (x *ScheduleBackupRequest) GetRetention() uint32 {
	if x != nil {
		return x.Retention
	}
	return 0
}

func (x *ScheduleBackupRequest) GetCompression() BackupCompression {
	if x != nil {
		return x.Compression
	}
	return BackupCompression_BACKUP_COMPRESSION_UNSPECIFIED
}

type ScheduleBackupResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	ScheduledBackupId string                 `protobuf:"bytes,1,opt,name=scheduled_backup_id,json=scheduledBackupId,proto3" json:"scheduled_backup_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ScheduleBackupResponse) Reset() {
	*x = ScheduleBackupResponse{}
	mi := &file_backup_v1_backup_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleBackupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleBackupResponse) ProtoMessage() {}

func (x *ScheduleBackupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleBackupResponse.ProtoReflect.Descriptor instead.
func (*ScheduleBackupResponse) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{6}
}

func (x *ScheduleBackupResponse) GetScheduledBackupId() string {
	if x != nil {
		return x.ScheduledBackupId
	}
	return ""
}

type ListScheduledBackupsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListScheduledBackupsRequest) Reset() {
	*x = ListScheduledBackupsRequest{}
	mi := &file_backup_v1_backup_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListScheduledBackupsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListScheduledBackupsRequest) ProtoMessage() {}

func (x *ListScheduledBackupsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListScheduledBackupsRequest.ProtoReflect.Descriptor instead.
func (*ListScheduledBackupsRequest) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{7}
}

type ListScheduledBackupsResponse struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ScheduledBackups []*ScheduledBackup     `protobuf:"bytes,1,rep,name=scheduled_backups,json=scheduledBackups,proto3" json:"scheduled_backups,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ListScheduledBackupsResponse) Reset() {
	*x = ListScheduledBackupsResponse{}
	mi := &file_backup_v1_backup_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListScheduledBackupsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListScheduledBackupsResponse) ProtoMessage() {}

func (x *ListScheduledBackupsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListScheduledBackupsResponse.ProtoReflect.Descriptor instead.
func (*ListScheduledBackupsResponse) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{8}
}

func (x *ListScheduledBackupsResponse) GetScheduledBackups() []*ScheduledBackup {
	if x != nil {
		return x.ScheduledBackups
	}
	return nil
}

type ChangeScheduledBackupRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	ScheduledBackupId string                 `protobuf:"bytes,1,opt,name=scheduled_backup_id,json=scheduledBackupId,proto3" json:"scheduled_backup_id,omitempty"`
	Enabled           *bool                  `protobuf:"varint,2,opt,name=enabled,proto3,oneof" json:"enabled,omitempty"`
	// How often backup should be run in cron format.
	CronExpression *string `protobuf:"bytes,3,opt,name=cron_expression,json=cronExpression,proto3,oneof" json:"cron_expression,omitempty"`
	// First backup wouldn't happen before this time.
	StartTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Name of backup.
	Name *string `protobuf:"bytes,5,opt,name=name,proto3,oneof" json:"name,omitempty"`
	// Human-readable description.
	Description *string `protobuf:"bytes,6,opt,name=description,proto3,oneof" json:"description,omitempty"`
	// How many times to retry a failed backup before giving up.
	Retries *uint32 `protobuf:"varint,7,opt,name=retries,proto3,oneof" json:"retries,omitempty"`
	// Delay between each retry. Should have a suffix in JSON: 1s, 1m, 1h.
	RetryInterval *durationpb.Duration `protobuf:"bytes,8,opt,name=retry_interval,json=retryInterval,proto3" json:"retry_interval,omitempty"`
	// How many artifacts keep. 0 - unlimited.
	Retention     *uint32 `protobuf:"varint,9,opt,name=retention,proto3,oneof" json:"retention,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChangeScheduledBackupRequest) Reset() {
	*x = ChangeScheduledBackupRequest{}
	mi := &file_backup_v1_backup_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChangeScheduledBackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChangeScheduledBackupRequest) ProtoMessage() {}

func (x *ChangeScheduledBackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChangeScheduledBackupRequest.ProtoReflect.Descriptor instead.
func (*ChangeScheduledBackupRequest) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{9}
}

func (x *ChangeScheduledBackupRequest) GetScheduledBackupId() string {
	if x != nil {
		return x.ScheduledBackupId
	}
	return ""
}

func (x *ChangeScheduledBackupRequest) GetEnabled() bool {
	if x != nil && x.Enabled != nil {
		return *x.Enabled
	}
	return false
}

func (x *ChangeScheduledBackupRequest) GetCronExpression() string {
	if x != nil && x.CronExpression != nil {
		return *x.CronExpression
	}
	return ""
}

func (x *ChangeScheduledBackupRequest) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ChangeScheduledBackupRequest) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ChangeScheduledBackupRequest) GetDescription() string {
	if x != nil && x.Description != nil {
		return *x.Description
	}
	return ""
}

func (x *ChangeScheduledBackupRequest) GetRetries() uint32 {
	if x != nil && x.Retries != nil {
		return *x.Retries
	}
	return 0
}

func (x *ChangeScheduledBackupRequest) GetRetryInterval() *durationpb.Duration {
	if x != nil {
		return x.RetryInterval
	}
	return nil
}

func (x *ChangeScheduledBackupRequest) GetRetention() uint32 {
	if x != nil && x.Retention != nil {
		return *x.Retention
	}
	return 0
}

type ChangeScheduledBackupResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChangeScheduledBackupResponse) Reset() {
	*x = ChangeScheduledBackupResponse{}
	mi := &file_backup_v1_backup_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChangeScheduledBackupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChangeScheduledBackupResponse) ProtoMessage() {}

func (x *ChangeScheduledBackupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChangeScheduledBackupResponse.ProtoReflect.Descriptor instead.
func (*ChangeScheduledBackupResponse) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{10}
}

type RemoveScheduledBackupRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	ScheduledBackupId string                 `protobuf:"bytes,1,opt,name=scheduled_backup_id,json=scheduledBackupId,proto3" json:"scheduled_backup_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *RemoveScheduledBackupRequest) Reset() {
	*x = RemoveScheduledBackupRequest{}
	mi := &file_backup_v1_backup_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveScheduledBackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveScheduledBackupRequest) ProtoMessage() {}

func (x *RemoveScheduledBackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveScheduledBackupRequest.ProtoReflect.Descriptor instead.
func (*RemoveScheduledBackupRequest) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{11}
}

func (x *RemoveScheduledBackupRequest) GetScheduledBackupId() string {
	if x != nil {
		return x.ScheduledBackupId
	}
	return ""
}

type RemoveScheduledBackupResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveScheduledBackupResponse) Reset() {
	*x = RemoveScheduledBackupResponse{}
	mi := &file_backup_v1_backup_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveScheduledBackupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveScheduledBackupResponse) ProtoMessage() {}

func (x *RemoveScheduledBackupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveScheduledBackupResponse.ProtoReflect.Descriptor instead.
func (*RemoveScheduledBackupResponse) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{12}
}

type GetLogsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ArtifactId    string                 `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	Offset        uint32                 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit         uint32                 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLogsRequest) Reset() {
	*x = GetLogsRequest{}
	mi := &file_backup_v1_backup_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLogsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLogsRequest) ProtoMessage() {}

func (x *GetLogsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLogsRequest.ProtoReflect.Descriptor instead.
func (*GetLogsRequest) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{13}
}

func (x *GetLogsRequest) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *GetLogsRequest) GetOffset() uint32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *GetLogsRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type GetLogsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Logs          []*LogChunk            `protobuf:"bytes,1,rep,name=logs,proto3" json:"logs,omitempty"`
	End           bool                   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLogsResponse) Reset() {
	*x = GetLogsResponse{}
	mi := &file_backup_v1_backup_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLogsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLogsResponse) ProtoMessage() {}

func (x *GetLogsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLogsResponse.ProtoReflect.Descriptor instead.
func (*GetLogsResponse) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{14}
}

func (x *GetLogsResponse) GetLogs() []*LogChunk {
	if x != nil {
		return x.Logs
	}
	return nil
}

func (x *GetLogsResponse) GetEnd() bool {
	if x != nil {
		return x.End
	}
	return false
}

type ListServiceCompressionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Service identifier.
	ServiceId     string `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListServiceCompressionRequest) Reset() {
	*x = ListServiceCompressionRequest{}
	mi := &file_backup_v1_backup_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListServiceCompressionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListServiceCompressionRequest) ProtoMessage() {}

func (x *ListServiceCompressionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListServiceCompressionRequest.ProtoReflect.Descriptor instead.
func (*ListServiceCompressionRequest) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{15}
}

func (x *ListServiceCompressionRequest) GetServiceId() string {
	if x != nil {
		return x.ServiceId
	}
	return ""
}

type ListServiceCompressionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Available compression methods for the service.
	CompressionMethods []BackupCompression `protobuf:"varint,1,rep,packed,name=compression_methods,json=compressionMethods,proto3,enum=backup.v1.BackupCompression" json:"compression_methods,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ListServiceCompressionResponse) Reset() {
	*x = ListServiceCompressionResponse{}
	mi := &file_backup_v1_backup_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListServiceCompressionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListServiceCompressionResponse) ProtoMessage() {}

func (x *ListServiceCompressionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_backup_v1_backup_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListServiceCompressionResponse.ProtoReflect.Descriptor instead.
func (*ListServiceCompressionResponse) Descriptor() ([]byte, []int) {
	return file_backup_v1_backup_proto_rawDescGZIP(), []int{16}
}

func (x *ListServiceCompressionResponse) GetCompressionMethods() []BackupCompression {
	if x != nil {
		return x.CompressionMethods
	}
	return nil
}

var File_backup_v1_backup_proto protoreflect.FileDescriptor

const file_backup_v1_backup_proto_rawDesc = "" +
	"\n" +
	"\x16backup/v1/backup.proto\x12\tbackup.v1\x1a\x19backup/v1/artifacts.proto\x1a\x16backup/v1/common.proto\x1a\x1cgoogle/api/annotations.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1binventory/v1/services.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\x1a\x17validate/validate.proto\"\x85\x03\n" +
	"\x12StartBackupRequest\x12&\n" +
	"\n" +
	"service_id\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\tserviceId\x12(\n" +
	"\vlocation_id\x18\x02 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\n" +
	"locationId\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12@\n" +
	"\x0eretry_interval\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\rretryInterval\x12\x18\n" +
	"\aretries\x18\x06 \x01(\rR\aretries\x123\n" +
	"\n" +
	"data_model\x18\a \x01(\x0e2\x14.backup.v1.DataModelR\tdataModel\x12\x16\n" +
	"\x06folder\x18\b \x01(\tR\x06folder\x12>\n" +
	"\vcompression\x18\t \x01(\x0e2\x1c.backup.v1.BackupCompressionR\vcompression\"6\n" +
	"\x13StartBackupResponse\x12\x1f\n" +
	"\vartifact_id\x18\x01 \x01(\tR\n" +
	"artifactId\"Q\n" +
	"%ListArtifactCompatibleServicesRequest\x12(\n" +
	"\vartifact_id\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\n" +
	"artifactId\"\x92\x01\n" +
	"&ListArtifactCompatibleServicesResponse\x120\n" +
	"\x05mysql\x18\x01 \x03(\v2\x1a.inventory.v1.MySQLServiceR\x05mysql\x126\n" +
	"\amongodb\x18\x02 \x03(\v2\x1c.inventory.v1.MongoDBServiceR\amongodb\"\xb5\x06\n" +
	"\x0fScheduledBackup\x12.\n" +
	"\x13scheduled_backup_id\x18\x01 \x01(\tR\x11scheduledBackupId\x12\x1d\n" +
	"\n" +
	"service_id\x18\x02 \x01(\tR\tserviceId\x12!\n" +
	"\fservice_name\x18\x03 \x01(\tR\vserviceName\x12\x1f\n" +
	"\vlocation_id\x18\x04 \x01(\tR\n" +
	"locationId\x12#\n" +
	"\rlocation_name\x18\x05 \x01(\tR\flocationName\x12\x16\n" +
	"\x06folder\x18\x06 \x01(\tR\x06folder\x12'\n" +
	"\x0fcron_expression\x18\a \x01(\tR\x0ecronExpression\x129\n" +
	"\n" +
	"start_time\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x12\x12\n" +
	"\x04name\x18\t \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\n" +
	" \x01(\tR\vdescription\x12\x18\n" +
	"\aenabled\x18\v \x01(\bR\aenabled\x12\x18\n" +
	"\aretries\x18\f \x01(\rR\aretries\x12@\n" +
	"\x0eretry_interval\x18\r \x01(\v2\x19.google.protobuf.DurationR\rretryInterval\x123\n" +
	"\n" +
	"data_model\x18\x0e \x01(\x0e2\x14.backup.v1.DataModelR\tdataModel\x12)\n" +
	"\x04mode\x18\x0f \x01(\x0e2\x15.backup.v1.BackupModeR\x04mode\x12\x16\n" +
	"\x06vendor\x18\x10 \x01(\tR\x06vendor\x125\n" +
	"\blast_run\x18\x11 \x01(\v2\x1a.google.protobuf.TimestampR\alastRun\x125\n" +
	"\bnext_run\x18\x12 \x01(\v2\x1a.google.protobuf.TimestampR\anextRun\x12\x1c\n" +
	"\tretention\x18\x13 \x01(\rR\tretention\x12>\n" +
	"\vcompression\x18\x14 \x01(\x0e2\x1c.backup.v1.BackupCompressionR\vcompression\"\xd8\x04\n" +
	"\x15ScheduleBackupRequest\x12&\n" +
	"\n" +
	"service_id\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\tserviceId\x12(\n" +
	"\vlocation_id\x18\x02 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\n" +
	"locationId\x12\x16\n" +
	"\x06folder\x18\x03 \x01(\tR\x06folder\x120\n" +
	"\x0fcron_expression\x18\x04 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\x0ecronExpression\x129\n" +
	"\n" +
	"start_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x12\x12\n" +
	"\x04name\x18\x06 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\a \x01(\tR\vdescription\x12\x18\n" +
	"\aenabled\x18\b \x01(\bR\aenabled\x12\x18\n" +
	"\aretries\x18\t \x01(\rR\aretries\x12@\n" +
	"\x0eretry_interval\x18\n" +
	" \x01(\v2\x19.google.protobuf.DurationR\rretryInterval\x12)\n" +
	"\x04mode\x18\v \x01(\x0e2\x15.backup.v1.BackupModeR\x04mode\x123\n" +
	"\n" +
	"data_model\x18\f \x01(\x0e2\x14.backup.v1.DataModelR\tdataModel\x12\x1c\n" +
	"\tretention\x18\r \x01(\rR\tretention\x12>\n" +
	"\vcompression\x18\x0e \x01(\x0e2\x1c.backup.v1.BackupCompressionR\vcompression\"H\n" +
	"\x16ScheduleBackupResponse\x12.\n" +
	"\x13scheduled_backup_id\x18\x01 \x01(\tR\x11scheduledBackupId\"\x1d\n" +
	"\x1bListScheduledBackupsRequest\"g\n" +
	"\x1cListScheduledBackupsResponse\x12G\n" +
	"\x11scheduled_backups\x18\x01 \x03(\v2\x1a.backup.v1.ScheduledBackupR\x10scheduledBackups\"\xf6\x03\n" +
	"\x1cChangeScheduledBackupRequest\x127\n" +
	"\x13scheduled_backup_id\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\x11scheduledBackupId\x12\x1d\n" +
	"\aenabled\x18\x02 \x01(\bH\x00R\aenabled\x88\x01\x01\x12,\n" +
	"\x0fcron_expression\x18\x03 \x01(\tH\x01R\x0ecronExpression\x88\x01\x01\x129\n" +
	"\n" +
	"start_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x12\x17\n" +
	"\x04name\x18\x05 \x01(\tH\x02R\x04name\x88\x01\x01\x12%\n" +
	"\vdescription\x18\x06 \x01(\tH\x03R\vdescription\x88\x01\x01\x12\x1d\n" +
	"\aretries\x18\a \x01(\rH\x04R\aretries\x88\x01\x01\x12@\n" +
	"\x0eretry_interval\x18\b \x01(\v2\x19.google.protobuf.DurationR\rretryInterval\x12!\n" +
	"\tretention\x18\t \x01(\rH\x05R\tretention\x88\x01\x01B\n" +
	"\n" +
	"\b_enabledB\x12\n" +
	"\x10_cron_expressionB\a\n" +
	"\x05_nameB\x0e\n" +
	"\f_descriptionB\n" +
	"\n" +
	"\b_retriesB\f\n" +
	"\n" +
	"_retention\"\x1f\n" +
	"\x1dChangeScheduledBackupResponse\"W\n" +
	"\x1cRemoveScheduledBackupRequest\x127\n" +
	"\x13scheduled_backup_id\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\x11scheduledBackupId\"\x1f\n" +
	"\x1dRemoveScheduledBackupResponse\"h\n" +
	"\x0eGetLogsRequest\x12(\n" +
	"\vartifact_id\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\n" +
	"artifactId\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\rR\x06offset\x12\x14\n" +
	"\x05limit\x18\x03 \x01(\rR\x05limit\"L\n" +
	"\x0fGetLogsResponse\x12'\n" +
	"\x04logs\x18\x01 \x03(\v2\x13.backup.v1.LogChunkR\x04logs\x12\x10\n" +
	"\x03end\x18\x02 \x01(\bR\x03end\"G\n" +
	"\x1dListServiceCompressionRequest\x12&\n" +
	"\n" +
	"service_id\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\tserviceId\"o\n" +
	"\x1eListServiceCompressionResponse\x12M\n" +
	"\x13compression_methods\x18\x01 \x03(\x0e2\x1c.backup.v1.BackupCompressionR\x12compressionMethods2\xc9\x14\n" +
	"\rBackupService\x12\xe7\x03\n" +
	"\vStartBackup\x12\x1d.backup.v1.StartBackupRequest\x1a\x1e.backup.v1.StartBackupResponse\"\x98\x03\x92A\xf8\x02\x12\x0eStart a Backup\x1a\xe5\x02Could return the Error message in the details containing specific ErrorCode indicating failure reason:\n" +
	"ERROR_CODE_XTRABACKUP_NOT_INSTALLED - xtrabackup is not installed on the service\n" +
	"ERROR_CODE_INVALID_XTRABACKUP - different versions of xtrabackup and xbcloud\n" +
	"ERROR_CODE_INCOMPATIBLE_XTRABACKUP - xtrabackup is not compatible with MySQL for taking a backup\x82\xd3\xe4\x93\x02\x16:\x01*\"\x11/v1/backups:start\x12\x97\x02\n" +
	"\x1eListArtifactCompatibleServices\x120.backup.v1.ListArtifactCompatibleServicesRequest\x1a1.backup.v1.ListArtifactCompatibleServicesResponse\"\x8f\x01\x92AW\x12\x18List Compatible Services\x1a;List services that are compatible with the backup artifact.\x82\xd3\xe4\x93\x02/\x12-/v1/backups/{artifact_id}/compatible-services\x12\xbb\x01\n" +
	"\x0eScheduleBackup\x12 .backup.v1.ScheduleBackupRequest\x1a!.backup.v1.ScheduleBackupResponse\"d\x92AB\x12\x11Schedule a Backup\x1a-Schedule a backup to run at a specified time.\x82\xd3\xe4\x93\x02\x19:\x01*\"\x14/v1/backups:schedule\x12\xbe\x01\n" +
	"\x14ListScheduledBackups\x12&.backup.v1.ListScheduledBackupsRequest\x1a'.backup.v1.ListScheduledBackupsResponse\"U\x92A5\x12\x16List Scheduled Backups\x1a\x1bList all scheduled backups.\x82\xd3\xe4\x93\x02\x17\x12\x15/v1/backups/scheduled\x12\xcc\x01\n" +
	"\x15ChangeScheduledBackup\x12'.backup.v1.ChangeScheduledBackupRequest\x1a(.backup.v1.ChangeScheduledBackupResponse\"`\x92A7\x12\x19Change a Scheduled Backup\x1a\x1aChange a scheduled backup.\x82\xd3\xe4\x93\x02 :\x01*\x1a\x1b/v1/backups:changeScheduled\x12\xcf\x01\n" +
	"\x15RemoveScheduledBackup\x12'.backup.v1.RemoveScheduledBackupRequest\x1a(.backup.v1.RemoveScheduledBackupResponse\"c\x92A7\x12\x19Remove a Scheduled Backup\x1a\x1aRemove a scheduled backup.\x82\xd3\xe4\x93\x02#*!/v1/backups/{scheduled_backup_id}\x12\xb3\x01\n" +
	"\aGetLogs\x12\x19.backup.v1.GetLogsRequest\x1a\x1a.backup.v1.GetLogsResponse\"q\x92AH\x12\bGet Logs\x1a<Get logs from the underlying tools for a backup/restore job.\x82\xd3\xe4\x93\x02 \x12\x1e/v1/backups/{artifact_id}/logs\x12\xa8\x01\n" +
	"\rListArtifacts\x12\x1f.backup.v1.ListArtifactsRequest\x1a .backup.v1.ListArtifactsResponse\"T\x92A4\x12\x0eList artifacts\x1a\"Return a list of backup artifacts.\x82\xd3\xe4\x93\x02\x17\x12\x15/v1/backups/artifacts\x12\xac\x01\n" +
	"\x0eDeleteArtifact\x12 .backup.v1.DeleteArtifactRequest\x1a!.backup.v1.DeleteArtifactResponse\"U\x92A'\x12\x0fDelete Artifact\x1a\x14Deletes an artifact.\x82\xd3\xe4\x93\x02%*#/v1/backups/artifacts/{artifact_id}\x12\xff\x01\n" +
	"\x12ListPitrTimeranges\x12$.backup.v1.ListPitrTimerangesRequest\x1a%.backup.v1.ListPitrTimerangesResponse\"\x9b\x01\x92A]\x12\x14List PITR Timeranges\x1aEReturn a list of available MongoDB point-in-time-recovery timeranges.\x82\xd3\xe4\x93\x025\x123/v1/backups/artifacts/{artifact_id}/pitr-timeranges\x12\x81\x02\n" +
	"\x16ListServiceCompression\x12(.backup.v1.ListServiceCompressionRequest\x1a).backup.v1.ListServiceCompressionResponse\"\x91\x01\x92AY\x12\x18List Service Compression\x1a=Return a list of available compression methods for a service.\x82\xd3\xe4\x93\x02/\x12-/v1/backups/services/{service_id}/compressionB\x90\x01\n" +
	"\rcom.backup.v1B\vBackupProtoP\x01Z-github.com/percona/pmm/api/backup/v1;backupv1\xa2\x02\x03BXX\xaa\x02\tBackup.V1\xca\x02\tBackup\\V1\xe2\x02\x15Backup\\V1\\GPBMetadata\xea\x02\n" +
	"Backup::V1b\x06proto3"

var (
	file_backup_v1_backup_proto_rawDescOnce sync.Once
	file_backup_v1_backup_proto_rawDescData []byte
)

func file_backup_v1_backup_proto_rawDescGZIP() []byte {
	file_backup_v1_backup_proto_rawDescOnce.Do(func() {
		file_backup_v1_backup_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_backup_v1_backup_proto_rawDesc), len(file_backup_v1_backup_proto_rawDesc)))
	})
	return file_backup_v1_backup_proto_rawDescData
}

var (
	file_backup_v1_backup_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
	file_backup_v1_backup_proto_goTypes  = []any{
		(*StartBackupRequest)(nil),                     // 0: backup.v1.StartBackupRequest
		(*StartBackupResponse)(nil),                    // 1: backup.v1.StartBackupResponse
		(*ListArtifactCompatibleServicesRequest)(nil),  // 2: backup.v1.ListArtifactCompatibleServicesRequest
		(*ListArtifactCompatibleServicesResponse)(nil), // 3: backup.v1.ListArtifactCompatibleServicesResponse
		(*ScheduledBackup)(nil),                        // 4: backup.v1.ScheduledBackup
		(*ScheduleBackupRequest)(nil),                  // 5: backup.v1.ScheduleBackupRequest
		(*ScheduleBackupResponse)(nil),                 // 6: backup.v1.ScheduleBackupResponse
		(*ListScheduledBackupsRequest)(nil),            // 7: backup.v1.ListScheduledBackupsRequest
		(*ListScheduledBackupsResponse)(nil),           // 8: backup.v1.ListScheduledBackupsResponse
		(*ChangeScheduledBackupRequest)(nil),           // 9: backup.v1.ChangeScheduledBackupRequest
		(*ChangeScheduledBackupResponse)(nil),          // 10: backup.v1.ChangeScheduledBackupResponse
		(*RemoveScheduledBackupRequest)(nil),           // 11: backup.v1.RemoveScheduledBackupRequest
		(*RemoveScheduledBackupResponse)(nil),          // 12: backup.v1.RemoveScheduledBackupResponse
		(*GetLogsRequest)(nil),                         // 13: backup.v1.GetLogsRequest
		(*GetLogsResponse)(nil),                        // 14: backup.v1.GetLogsResponse
		(*ListServiceCompressionRequest)(nil),          // 15: backup.v1.ListServiceCompressionRequest
		(*ListServiceCompressionResponse)(nil),         // 16: backup.v1.ListServiceCompressionResponse
		(*durationpb.Duration)(nil),                    // 17: google.protobuf.Duration
		(DataModel)(0),                                 // 18: backup.v1.DataModel
		(BackupCompression)(0),                         // 19: backup.v1.BackupCompression
		(*v1.MySQLService)(nil),                        // 20: inventory.v1.MySQLService
		(*v1.MongoDBService)(nil),                      // 21: inventory.v1.MongoDBService
		(*timestamppb.Timestamp)(nil),                  // 22: google.protobuf.Timestamp
		(BackupMode)(0),                                // 23: backup.v1.BackupMode
		(*LogChunk)(nil),                               // 24: backup.v1.LogChunk
		(*ListArtifactsRequest)(nil),                   // 25: backup.v1.ListArtifactsRequest
		(*DeleteArtifactRequest)(nil),                  // 26: backup.v1.DeleteArtifactRequest
		(*ListPitrTimerangesRequest)(nil),              // 27: backup.v1.ListPitrTimerangesRequest
		(*ListArtifactsResponse)(nil),                  // 28: backup.v1.ListArtifactsResponse
		(*DeleteArtifactResponse)(nil),                 // 29: backup.v1.DeleteArtifactResponse
		(*ListPitrTimerangesResponse)(nil),             // 30: backup.v1.ListPitrTimerangesResponse
	}
)

var file_backup_v1_backup_proto_depIdxs = []int32{
	17, // 0: backup.v1.StartBackupRequest.retry_interval:type_name -> google.protobuf.Duration
	18, // 1: backup.v1.StartBackupRequest.data_model:type_name -> backup.v1.DataModel
	19, // 2: backup.v1.StartBackupRequest.compression:type_name -> backup.v1.BackupCompression
	20, // 3: backup.v1.ListArtifactCompatibleServicesResponse.mysql:type_name -> inventory.v1.MySQLService
	21, // 4: backup.v1.ListArtifactCompatibleServicesResponse.mongodb:type_name -> inventory.v1.MongoDBService
	22, // 5: backup.v1.ScheduledBackup.start_time:type_name -> google.protobuf.Timestamp
	17, // 6: backup.v1.ScheduledBackup.retry_interval:type_name -> google.protobuf.Duration
	18, // 7: backup.v1.ScheduledBackup.data_model:type_name -> backup.v1.DataModel
	23, // 8: backup.v1.ScheduledBackup.mode:type_name -> backup.v1.BackupMode
	22, // 9: backup.v1.ScheduledBackup.last_run:type_name -> google.protobuf.Timestamp
	22, // 10: backup.v1.ScheduledBackup.next_run:type_name -> google.protobuf.Timestamp
	19, // 11: backup.v1.ScheduledBackup.compression:type_name -> backup.v1.BackupCompression
	22, // 12: backup.v1.ScheduleBackupRequest.start_time:type_name -> google.protobuf.Timestamp
	17, // 13: backup.v1.ScheduleBackupRequest.retry_interval:type_name -> google.protobuf.Duration
	23, // 14: backup.v1.ScheduleBackupRequest.mode:type_name -> backup.v1.BackupMode
	18, // 15: backup.v1.ScheduleBackupRequest.data_model:type_name -> backup.v1.DataModel
	19, // 16: backup.v1.ScheduleBackupRequest.compression:type_name -> backup.v1.BackupCompression
	4,  // 17: backup.v1.ListScheduledBackupsResponse.scheduled_backups:type_name -> backup.v1.ScheduledBackup
	22, // 18: backup.v1.ChangeScheduledBackupRequest.start_time:type_name -> google.protobuf.Timestamp
	17, // 19: backup.v1.ChangeScheduledBackupRequest.retry_interval:type_name -> google.protobuf.Duration
	24, // 20: backup.v1.GetLogsResponse.logs:type_name -> backup.v1.LogChunk
	19, // 21: backup.v1.ListServiceCompressionResponse.compression_methods:type_name -> backup.v1.BackupCompression
	0,  // 22: backup.v1.BackupService.StartBackup:input_type -> backup.v1.StartBackupRequest
	2,  // 23: backup.v1.BackupService.ListArtifactCompatibleServices:input_type -> backup.v1.ListArtifactCompatibleServicesRequest
	5,  // 24: backup.v1.BackupService.ScheduleBackup:input_type -> backup.v1.ScheduleBackupRequest
	7,  // 25: backup.v1.BackupService.ListScheduledBackups:input_type -> backup.v1.ListScheduledBackupsRequest
	9,  // 26: backup.v1.BackupService.ChangeScheduledBackup:input_type -> backup.v1.ChangeScheduledBackupRequest
	11, // 27: backup.v1.BackupService.RemoveScheduledBackup:input_type -> backup.v1.RemoveScheduledBackupRequest
	13, // 28: backup.v1.BackupService.GetLogs:input_type -> backup.v1.GetLogsRequest
	25, // 29: backup.v1.BackupService.ListArtifacts:input_type -> backup.v1.ListArtifactsRequest
	26, // 30: backup.v1.BackupService.DeleteArtifact:input_type -> backup.v1.DeleteArtifactRequest
	27, // 31: backup.v1.BackupService.ListPitrTimeranges:input_type -> backup.v1.ListPitrTimerangesRequest
	15, // 32: backup.v1.BackupService.ListServiceCompression:input_type -> backup.v1.ListServiceCompressionRequest
	1,  // 33: backup.v1.BackupService.StartBackup:output_type -> backup.v1.StartBackupResponse
	3,  // 34: backup.v1.BackupService.ListArtifactCompatibleServices:output_type -> backup.v1.ListArtifactCompatibleServicesResponse
	6,  // 35: backup.v1.BackupService.ScheduleBackup:output_type -> backup.v1.ScheduleBackupResponse
	8,  // 36: backup.v1.BackupService.ListScheduledBackups:output_type -> backup.v1.ListScheduledBackupsResponse
	10, // 37: backup.v1.BackupService.ChangeScheduledBackup:output_type -> backup.v1.ChangeScheduledBackupResponse
	12, // 38: backup.v1.BackupService.RemoveScheduledBackup:output_type -> backup.v1.RemoveScheduledBackupResponse
	14, // 39: backup.v1.BackupService.GetLogs:output_type -> backup.v1.GetLogsResponse
	28, // 40: backup.v1.BackupService.ListArtifacts:output_type -> backup.v1.ListArtifactsResponse
	29, // 41: backup.v1.BackupService.DeleteArtifact:output_type -> backup.v1.DeleteArtifactResponse
	30, // 42: backup.v1.BackupService.ListPitrTimeranges:output_type -> backup.v1.ListPitrTimerangesResponse
	16, // 43: backup.v1.BackupService.ListServiceCompression:output_type -> backup.v1.ListServiceCompressionResponse
	33, // [33:44] is the sub-list for method output_type
	22, // [22:33] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_backup_v1_backup_proto_init() }
func file_backup_v1_backup_proto_init() {
	if File_backup_v1_backup_proto != nil {
		return
	}
	file_backup_v1_artifacts_proto_init()
	file_backup_v1_common_proto_init()
	file_backup_v1_backup_proto_msgTypes[9].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_backup_v1_backup_proto_rawDesc), len(file_backup_v1_backup_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_backup_v1_backup_proto_goTypes,
		DependencyIndexes: file_backup_v1_backup_proto_depIdxs,
		MessageInfos:      file_backup_v1_backup_proto_msgTypes,
	}.Build()
	File_backup_v1_backup_proto = out.File
	file_backup_v1_backup_proto_goTypes = nil
	file_backup_v1_backup_proto_depIdxs = nil
}
