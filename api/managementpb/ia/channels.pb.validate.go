// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: managementpb/ia/channels.proto

package iav1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on BasicAuth with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BasicAuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BasicAuth with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BasicAuthMultiError, or nil
// if none found.
func (m *BasicAuth) ValidateAll() error {
	return m.validate(true)
}

func (m *BasicAuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for PasswordFile

	if len(errors) > 0 {
		return BasicAuthMultiError(errors)
	}

	return nil
}

// BasicAuthMultiError is an error wrapping multiple validation errors returned
// by BasicAuth.ValidateAll() if the designated constraints aren't met.
type BasicAuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BasicAuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BasicAuthMultiError) AllErrors() []error { return m }

// BasicAuthValidationError is the validation error returned by
// BasicAuth.Validate if the designated constraints aren't met.
type BasicAuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BasicAuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BasicAuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BasicAuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BasicAuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BasicAuthValidationError) ErrorName() string { return "BasicAuthValidationError" }

// Error satisfies the builtin error interface
func (e BasicAuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBasicAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BasicAuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BasicAuthValidationError{}

// Validate checks the field values on TLSConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TLSConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TLSConfigMultiError, or nil
// if none found.
func (m *TLSConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CaFile

	// no validation rules for CertFile

	// no validation rules for KeyFile

	// no validation rules for ServerName

	// no validation rules for InsecureSkipVerify

	// no validation rules for CaFileContent

	// no validation rules for CertFileContent

	// no validation rules for KeyFileContent

	if len(errors) > 0 {
		return TLSConfigMultiError(errors)
	}

	return nil
}

// TLSConfigMultiError is an error wrapping multiple validation errors returned
// by TLSConfig.ValidateAll() if the designated constraints aren't met.
type TLSConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSConfigMultiError) AllErrors() []error { return m }

// TLSConfigValidationError is the validation error returned by
// TLSConfig.Validate if the designated constraints aren't met.
type TLSConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSConfigValidationError) ErrorName() string { return "TLSConfigValidationError" }

// Error satisfies the builtin error interface
func (e TLSConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSConfigValidationError{}

// Validate checks the field values on HTTPConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HTTPConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HTTPConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HTTPConfigMultiError, or
// nil if none found.
func (m *HTTPConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *HTTPConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBasicAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HTTPConfigValidationError{
					field:  "BasicAuth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HTTPConfigValidationError{
					field:  "BasicAuth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBasicAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HTTPConfigValidationError{
				field:  "BasicAuth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BearerToken

	// no validation rules for BearerTokenFile

	if all {
		switch v := interface{}(m.GetTlsConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HTTPConfigValidationError{
					field:  "TlsConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HTTPConfigValidationError{
					field:  "TlsConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTlsConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HTTPConfigValidationError{
				field:  "TlsConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProxyUrl

	if len(errors) > 0 {
		return HTTPConfigMultiError(errors)
	}

	return nil
}

// HTTPConfigMultiError is an error wrapping multiple validation errors
// returned by HTTPConfig.ValidateAll() if the designated constraints aren't met.
type HTTPConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HTTPConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HTTPConfigMultiError) AllErrors() []error { return m }

// HTTPConfigValidationError is the validation error returned by
// HTTPConfig.Validate if the designated constraints aren't met.
type HTTPConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTTPConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTTPConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTTPConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTTPConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTTPConfigValidationError) ErrorName() string { return "HTTPConfigValidationError" }

// Error satisfies the builtin error interface
func (e HTTPConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTTPConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTTPConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTTPConfigValidationError{}

// Validate checks the field values on EmailConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailConfigMultiError, or
// nil if none found.
func (m *EmailConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SendResolved

	if len(m.GetTo()) < 1 {
		err := EmailConfigValidationError{
			field:  "To",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EmailConfigMultiError(errors)
	}

	return nil
}

// EmailConfigMultiError is an error wrapping multiple validation errors
// returned by EmailConfig.ValidateAll() if the designated constraints aren't met.
type EmailConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailConfigMultiError) AllErrors() []error { return m }

// EmailConfigValidationError is the validation error returned by
// EmailConfig.Validate if the designated constraints aren't met.
type EmailConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailConfigValidationError) ErrorName() string { return "EmailConfigValidationError" }

// Error satisfies the builtin error interface
func (e EmailConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailConfigValidationError{}

// Validate checks the field values on PagerDutyConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PagerDutyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PagerDutyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PagerDutyConfigMultiError, or nil if none found.
func (m *PagerDutyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PagerDutyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SendResolved

	// no validation rules for RoutingKey

	// no validation rules for ServiceKey

	if len(errors) > 0 {
		return PagerDutyConfigMultiError(errors)
	}

	return nil
}

// PagerDutyConfigMultiError is an error wrapping multiple validation errors
// returned by PagerDutyConfig.ValidateAll() if the designated constraints
// aren't met.
type PagerDutyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PagerDutyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PagerDutyConfigMultiError) AllErrors() []error { return m }

// PagerDutyConfigValidationError is the validation error returned by
// PagerDutyConfig.Validate if the designated constraints aren't met.
type PagerDutyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PagerDutyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PagerDutyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PagerDutyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PagerDutyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PagerDutyConfigValidationError) ErrorName() string { return "PagerDutyConfigValidationError" }

// Error satisfies the builtin error interface
func (e PagerDutyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPagerDutyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PagerDutyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PagerDutyConfigValidationError{}

// Validate checks the field values on SlackConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SlackConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SlackConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SlackConfigMultiError, or
// nil if none found.
func (m *SlackConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SlackConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SendResolved

	if utf8.RuneCountInString(m.GetChannel()) < 1 {
		err := SlackConfigValidationError{
			field:  "Channel",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SlackConfigMultiError(errors)
	}

	return nil
}

// SlackConfigMultiError is an error wrapping multiple validation errors
// returned by SlackConfig.ValidateAll() if the designated constraints aren't met.
type SlackConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SlackConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SlackConfigMultiError) AllErrors() []error { return m }

// SlackConfigValidationError is the validation error returned by
// SlackConfig.Validate if the designated constraints aren't met.
type SlackConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SlackConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SlackConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SlackConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SlackConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SlackConfigValidationError) ErrorName() string { return "SlackConfigValidationError" }

// Error satisfies the builtin error interface
func (e SlackConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSlackConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SlackConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SlackConfigValidationError{}

// Validate checks the field values on WebhookConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebhookConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebhookConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebhookConfigMultiError, or
// nil if none found.
func (m *WebhookConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *WebhookConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SendResolved

	if utf8.RuneCountInString(m.GetUrl()) < 1 {
		err := WebhookConfigValidationError{
			field:  "Url",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetHttpConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookConfigValidationError{
					field:  "HttpConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookConfigValidationError{
					field:  "HttpConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHttpConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookConfigValidationError{
				field:  "HttpConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxAlerts

	if len(errors) > 0 {
		return WebhookConfigMultiError(errors)
	}

	return nil
}

// WebhookConfigMultiError is an error wrapping multiple validation errors
// returned by WebhookConfig.ValidateAll() if the designated constraints
// aren't met.
type WebhookConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebhookConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebhookConfigMultiError) AllErrors() []error { return m }

// WebhookConfigValidationError is the validation error returned by
// WebhookConfig.Validate if the designated constraints aren't met.
type WebhookConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebhookConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebhookConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebhookConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebhookConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebhookConfigValidationError) ErrorName() string { return "WebhookConfigValidationError" }

// Error satisfies the builtin error interface
func (e WebhookConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebhookConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebhookConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebhookConfigValidationError{}

// Validate checks the field values on Channel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Channel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Channel with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChannelMultiError, or nil if none found.
func (m *Channel) ValidateAll() error {
	return m.validate(true)
}

func (m *Channel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChannelId

	// no validation rules for Summary

	// no validation rules for Disabled

	switch v := m.Channel.(type) {
	case *Channel_EmailConfig:
		if v == nil {
			err := ChannelValidationError{
				field:  "Channel",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEmailConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChannelValidationError{
						field:  "EmailConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChannelValidationError{
						field:  "EmailConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmailConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChannelValidationError{
					field:  "EmailConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Channel_PagerdutyConfig:
		if v == nil {
			err := ChannelValidationError{
				field:  "Channel",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPagerdutyConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChannelValidationError{
						field:  "PagerdutyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChannelValidationError{
						field:  "PagerdutyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPagerdutyConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChannelValidationError{
					field:  "PagerdutyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Channel_SlackConfig:
		if v == nil {
			err := ChannelValidationError{
				field:  "Channel",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSlackConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChannelValidationError{
						field:  "SlackConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChannelValidationError{
						field:  "SlackConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSlackConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChannelValidationError{
					field:  "SlackConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Channel_WebhookConfig:
		if v == nil {
			err := ChannelValidationError{
				field:  "Channel",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWebhookConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChannelValidationError{
						field:  "WebhookConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChannelValidationError{
						field:  "WebhookConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebhookConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChannelValidationError{
					field:  "WebhookConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ChannelMultiError(errors)
	}

	return nil
}

// ChannelMultiError is an error wrapping multiple validation errors returned
// by Channel.ValidateAll() if the designated constraints aren't met.
type ChannelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChannelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChannelMultiError) AllErrors() []error { return m }

// ChannelValidationError is the validation error returned by Channel.Validate
// if the designated constraints aren't met.
type ChannelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChannelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChannelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChannelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChannelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChannelValidationError) ErrorName() string { return "ChannelValidationError" }

// Error satisfies the builtin error interface
func (e ChannelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChannel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChannelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChannelValidationError{}

// Validate checks the field values on ListChannelsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChannelsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChannelsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChannelsRequestMultiError, or nil if none found.
func (m *ListChannelsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChannelsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageParams()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChannelsRequestValidationError{
					field:  "PageParams",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChannelsRequestValidationError{
					field:  "PageParams",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageParams()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChannelsRequestValidationError{
				field:  "PageParams",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListChannelsRequestMultiError(errors)
	}

	return nil
}

// ListChannelsRequestMultiError is an error wrapping multiple validation
// errors returned by ListChannelsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListChannelsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChannelsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChannelsRequestMultiError) AllErrors() []error { return m }

// ListChannelsRequestValidationError is the validation error returned by
// ListChannelsRequest.Validate if the designated constraints aren't met.
type ListChannelsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChannelsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChannelsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChannelsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChannelsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChannelsRequestValidationError) ErrorName() string {
	return "ListChannelsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListChannelsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChannelsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChannelsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChannelsRequestValidationError{}

// Validate checks the field values on ListChannelsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChannelsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChannelsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChannelsResponseMultiError, or nil if none found.
func (m *ListChannelsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChannelsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetChannels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListChannelsResponseValidationError{
						field:  fmt.Sprintf("Channels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListChannelsResponseValidationError{
						field:  fmt.Sprintf("Channels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListChannelsResponseValidationError{
					field:  fmt.Sprintf("Channels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTotals()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChannelsResponseValidationError{
					field:  "Totals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChannelsResponseValidationError{
					field:  "Totals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotals()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChannelsResponseValidationError{
				field:  "Totals",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListChannelsResponseMultiError(errors)
	}

	return nil
}

// ListChannelsResponseMultiError is an error wrapping multiple validation
// errors returned by ListChannelsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListChannelsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChannelsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChannelsResponseMultiError) AllErrors() []error { return m }

// ListChannelsResponseValidationError is the validation error returned by
// ListChannelsResponse.Validate if the designated constraints aren't met.
type ListChannelsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChannelsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChannelsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChannelsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChannelsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChannelsResponseValidationError) ErrorName() string {
	return "ListChannelsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListChannelsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChannelsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChannelsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChannelsResponseValidationError{}

// Validate checks the field values on AddChannelRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddChannelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddChannelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddChannelRequestMultiError, or nil if none found.
func (m *AddChannelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddChannelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSummary()) < 1 {
		err := AddChannelRequestValidationError{
			field:  "Summary",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetEmailConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddChannelRequestValidationError{
					field:  "EmailConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddChannelRequestValidationError{
					field:  "EmailConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmailConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddChannelRequestValidationError{
				field:  "EmailConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPagerdutyConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddChannelRequestValidationError{
					field:  "PagerdutyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddChannelRequestValidationError{
					field:  "PagerdutyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagerdutyConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddChannelRequestValidationError{
				field:  "PagerdutyConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSlackConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddChannelRequestValidationError{
					field:  "SlackConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddChannelRequestValidationError{
					field:  "SlackConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSlackConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddChannelRequestValidationError{
				field:  "SlackConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebhookConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddChannelRequestValidationError{
					field:  "WebhookConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddChannelRequestValidationError{
					field:  "WebhookConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebhookConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddChannelRequestValidationError{
				field:  "WebhookConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Disabled

	if len(errors) > 0 {
		return AddChannelRequestMultiError(errors)
	}

	return nil
}

// AddChannelRequestMultiError is an error wrapping multiple validation errors
// returned by AddChannelRequest.ValidateAll() if the designated constraints
// aren't met.
type AddChannelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddChannelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddChannelRequestMultiError) AllErrors() []error { return m }

// AddChannelRequestValidationError is the validation error returned by
// AddChannelRequest.Validate if the designated constraints aren't met.
type AddChannelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddChannelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddChannelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddChannelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddChannelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddChannelRequestValidationError) ErrorName() string {
	return "AddChannelRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddChannelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddChannelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddChannelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddChannelRequestValidationError{}

// Validate checks the field values on AddChannelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddChannelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddChannelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddChannelResponseMultiError, or nil if none found.
func (m *AddChannelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddChannelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChannelId

	if len(errors) > 0 {
		return AddChannelResponseMultiError(errors)
	}

	return nil
}

// AddChannelResponseMultiError is an error wrapping multiple validation errors
// returned by AddChannelResponse.ValidateAll() if the designated constraints
// aren't met.
type AddChannelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddChannelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddChannelResponseMultiError) AllErrors() []error { return m }

// AddChannelResponseValidationError is the validation error returned by
// AddChannelResponse.Validate if the designated constraints aren't met.
type AddChannelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddChannelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddChannelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddChannelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddChannelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddChannelResponseValidationError) ErrorName() string {
	return "AddChannelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddChannelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddChannelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddChannelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddChannelResponseValidationError{}

// Validate checks the field values on ChangeChannelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeChannelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeChannelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeChannelRequestMultiError, or nil if none found.
func (m *ChangeChannelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeChannelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChannelId()) < 1 {
		err := ChangeChannelRequestValidationError{
			field:  "ChannelId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Summary

	if all {
		switch v := interface{}(m.GetEmailConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeChannelRequestValidationError{
					field:  "EmailConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeChannelRequestValidationError{
					field:  "EmailConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmailConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeChannelRequestValidationError{
				field:  "EmailConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPagerdutyConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeChannelRequestValidationError{
					field:  "PagerdutyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeChannelRequestValidationError{
					field:  "PagerdutyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagerdutyConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeChannelRequestValidationError{
				field:  "PagerdutyConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSlackConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeChannelRequestValidationError{
					field:  "SlackConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeChannelRequestValidationError{
					field:  "SlackConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSlackConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeChannelRequestValidationError{
				field:  "SlackConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebhookConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeChannelRequestValidationError{
					field:  "WebhookConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeChannelRequestValidationError{
					field:  "WebhookConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebhookConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeChannelRequestValidationError{
				field:  "WebhookConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Disabled

	if len(errors) > 0 {
		return ChangeChannelRequestMultiError(errors)
	}

	return nil
}

// ChangeChannelRequestMultiError is an error wrapping multiple validation
// errors returned by ChangeChannelRequest.ValidateAll() if the designated
// constraints aren't met.
type ChangeChannelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeChannelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeChannelRequestMultiError) AllErrors() []error { return m }

// ChangeChannelRequestValidationError is the validation error returned by
// ChangeChannelRequest.Validate if the designated constraints aren't met.
type ChangeChannelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeChannelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeChannelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeChannelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeChannelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeChannelRequestValidationError) ErrorName() string {
	return "ChangeChannelRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeChannelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeChannelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeChannelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeChannelRequestValidationError{}

// Validate checks the field values on ChangeChannelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeChannelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeChannelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeChannelResponseMultiError, or nil if none found.
func (m *ChangeChannelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeChannelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ChangeChannelResponseMultiError(errors)
	}

	return nil
}

// ChangeChannelResponseMultiError is an error wrapping multiple validation
// errors returned by ChangeChannelResponse.ValidateAll() if the designated
// constraints aren't met.
type ChangeChannelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeChannelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeChannelResponseMultiError) AllErrors() []error { return m }

// ChangeChannelResponseValidationError is the validation error returned by
// ChangeChannelResponse.Validate if the designated constraints aren't met.
type ChangeChannelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeChannelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeChannelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeChannelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeChannelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeChannelResponseValidationError) ErrorName() string {
	return "ChangeChannelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeChannelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeChannelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeChannelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeChannelResponseValidationError{}

// Validate checks the field values on RemoveChannelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveChannelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveChannelRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveChannelRequestMultiError, or nil if none found.
func (m *RemoveChannelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveChannelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChannelId()) < 1 {
		err := RemoveChannelRequestValidationError{
			field:  "ChannelId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RemoveChannelRequestMultiError(errors)
	}

	return nil
}

// RemoveChannelRequestMultiError is an error wrapping multiple validation
// errors returned by RemoveChannelRequest.ValidateAll() if the designated
// constraints aren't met.
type RemoveChannelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveChannelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveChannelRequestMultiError) AllErrors() []error { return m }

// RemoveChannelRequestValidationError is the validation error returned by
// RemoveChannelRequest.Validate if the designated constraints aren't met.
type RemoveChannelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveChannelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveChannelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveChannelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveChannelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveChannelRequestValidationError) ErrorName() string {
	return "RemoveChannelRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveChannelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveChannelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveChannelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveChannelRequestValidationError{}

// Validate checks the field values on RemoveChannelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveChannelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveChannelResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveChannelResponseMultiError, or nil if none found.
func (m *RemoveChannelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveChannelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RemoveChannelResponseMultiError(errors)
	}

	return nil
}

// RemoveChannelResponseMultiError is an error wrapping multiple validation
// errors returned by RemoveChannelResponse.ValidateAll() if the designated
// constraints aren't met.
type RemoveChannelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveChannelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveChannelResponseMultiError) AllErrors() []error { return m }

// RemoveChannelResponseValidationError is the validation error returned by
// RemoveChannelResponse.Validate if the designated constraints aren't met.
type RemoveChannelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveChannelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveChannelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveChannelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveChannelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveChannelResponseValidationError) ErrorName() string {
	return "RemoveChannelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveChannelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveChannelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveChannelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveChannelResponseValidationError{}
