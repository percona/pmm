// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: user/v1/user.proto

package userv1mcp

import (
	"context"
	"encoding/json"

	"connectrpc.com/connect"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	grpc "google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"

	v1 "github.com/percona/pmm/api/user/v1"
)

var (
	UserService_GetUserTool    = mcp.Tool{Name: "user_v1_UserService_GetUser", Description: "", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
	UserService_ListUsersTool  = mcp.Tool{Name: "user_v1_UserService_ListUsers", Description: "", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
	UserService_UpdateUserTool = mcp.Tool{Name: "user_v1_UserService_UpdateUser", Description: "", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x6f, 0x75, 0x72, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x62, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x22, 0x7d, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x5f, 0x74, 0x6f, 0x75, 0x72, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x62, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x22, 0x7d, 0x2c, 0x22, 0x73, 0x6e, 0x6f, 0x6f, 0x7a, 0x65, 0x64, 0x5f, 0x70, 0x6d, 0x6d, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
)

// UserServiceServer is compatible with the grpc-go server interface.
type UserServiceServer interface {
	GetUser(ctx context.Context, req *v1.GetUserRequest) (*v1.GetUserResponse, error)
	ListUsers(ctx context.Context, req *v1.ListUsersRequest) (*v1.ListUsersResponse, error)
	UpdateUser(ctx context.Context, req *v1.UpdateUserRequest) (*v1.UpdateUserResponse, error)
}

func RegisterUserServiceHandler(s *mcpserver.MCPServer, srv UserServiceServer) {
	s.AddTool(UserService_GetUserTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.GetUserRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.GetUser(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(UserService_ListUsersTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.ListUsersRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.ListUsers(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(UserService_UpdateUserTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.UpdateUserRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.UpdateUser(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// UserServiceClient is compatible with the grpc-go client interface.
type UserServiceClient interface {
	GetUser(ctx context.Context, req *v1.GetUserRequest, opts ...grpc.CallOption) (*v1.GetUserResponse, error)
	ListUsers(ctx context.Context, req *v1.ListUsersRequest, opts ...grpc.CallOption) (*v1.ListUsersResponse, error)
	UpdateUser(ctx context.Context, req *v1.UpdateUserRequest, opts ...grpc.CallOption) (*v1.UpdateUserResponse, error)
}

// ConnectUserServiceClient is compatible with the connectrpc-go client interface.
type ConnectUserServiceClient interface {
	GetUser(ctx context.Context, req *connect.Request[v1.GetUserRequest]) (*connect.Response[v1.GetUserResponse], error)
	ListUsers(ctx context.Context, req *connect.Request[v1.ListUsersRequest]) (*connect.Response[v1.ListUsersResponse], error)
	UpdateUser(ctx context.Context, req *connect.Request[v1.UpdateUserRequest]) (*connect.Response[v1.UpdateUserResponse], error)
}

// ForwardToConnectUserServiceClient registers a connectrpc client, to forward MCP calls to it.
func ForwardToConnectUserServiceClient(s *mcpserver.MCPServer, client ConnectUserServiceClient) {
	s.AddTool(UserService_GetUserTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.GetUserRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetUser(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(UserService_ListUsersTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.ListUsersRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListUsers(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(UserService_UpdateUserTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.UpdateUserRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.UpdateUser(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// ForwardToUserServiceClient registers a gRPC client, to forward MCP calls to it.
func ForwardToUserServiceClient(s *mcpserver.MCPServer, client UserServiceClient) {
	s.AddTool(UserService_GetUserTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.GetUserRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetUser(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(UserService_ListUsersTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.ListUsersRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListUsers(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(UserService_UpdateUserTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req v1.UpdateUserRequest
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.UpdateUser(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
