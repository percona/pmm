// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: server/v1/server.proto

package serverv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on VersionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VersionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VersionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VersionInfoMultiError, or
// nil if none found.
func (m *VersionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *VersionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for FullVersion

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionInfoValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionInfoValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionInfoValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VersionInfoMultiError(errors)
	}

	return nil
}

// VersionInfoMultiError is an error wrapping multiple validation errors
// returned by VersionInfo.ValidateAll() if the designated constraints aren't met.
type VersionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionInfoMultiError) AllErrors() []error { return m }

// VersionInfoValidationError is the validation error returned by
// VersionInfo.Validate if the designated constraints aren't met.
type VersionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionInfoValidationError) ErrorName() string { return "VersionInfoValidationError" }

// Error satisfies the builtin error interface
func (e VersionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionInfoValidationError{}

// Validate checks the field values on VersionRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VersionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VersionRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VersionRequestMultiError,
// or nil if none found.
func (m *VersionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VersionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dummy

	if len(errors) > 0 {
		return VersionRequestMultiError(errors)
	}

	return nil
}

// VersionRequestMultiError is an error wrapping multiple validation errors
// returned by VersionRequest.ValidateAll() if the designated constraints
// aren't met.
type VersionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionRequestMultiError) AllErrors() []error { return m }

// VersionRequestValidationError is the validation error returned by
// VersionRequest.Validate if the designated constraints aren't met.
type VersionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionRequestValidationError) ErrorName() string { return "VersionRequestValidationError" }

// Error satisfies the builtin error interface
func (e VersionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionRequestValidationError{}

// Validate checks the field values on VersionResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VersionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VersionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VersionResponseMultiError, or nil if none found.
func (m *VersionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VersionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetServer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionResponseValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionResponseValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionResponseValidationError{
				field:  "Server",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetManaged()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionResponseValidationError{
					field:  "Managed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionResponseValidationError{
					field:  "Managed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetManaged()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionResponseValidationError{
				field:  "Managed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DistributionMethod

	if len(errors) > 0 {
		return VersionResponseMultiError(errors)
	}

	return nil
}

// VersionResponseMultiError is an error wrapping multiple validation errors
// returned by VersionResponse.ValidateAll() if the designated constraints
// aren't met.
type VersionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionResponseMultiError) AllErrors() []error { return m }

// VersionResponseValidationError is the validation error returned by
// VersionResponse.Validate if the designated constraints aren't met.
type VersionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionResponseValidationError) ErrorName() string { return "VersionResponseValidationError" }

// Error satisfies the builtin error interface
func (e VersionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionResponseValidationError{}

// Validate checks the field values on ReadinessRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadinessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadinessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadinessRequestMultiError, or nil if none found.
func (m *ReadinessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadinessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReadinessRequestMultiError(errors)
	}

	return nil
}

// ReadinessRequestMultiError is an error wrapping multiple validation errors
// returned by ReadinessRequest.ValidateAll() if the designated constraints
// aren't met.
type ReadinessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadinessRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadinessRequestMultiError) AllErrors() []error { return m }

// ReadinessRequestValidationError is the validation error returned by
// ReadinessRequest.Validate if the designated constraints aren't met.
type ReadinessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadinessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadinessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadinessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadinessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadinessRequestValidationError) ErrorName() string { return "ReadinessRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReadinessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadinessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadinessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadinessRequestValidationError{}

// Validate checks the field values on ReadinessResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadinessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadinessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadinessResponseMultiError, or nil if none found.
func (m *ReadinessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadinessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReadinessResponseMultiError(errors)
	}

	return nil
}

// ReadinessResponseMultiError is an error wrapping multiple validation errors
// returned by ReadinessResponse.ValidateAll() if the designated constraints
// aren't met.
type ReadinessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadinessResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadinessResponseMultiError) AllErrors() []error { return m }

// ReadinessResponseValidationError is the validation error returned by
// ReadinessResponse.Validate if the designated constraints aren't met.
type ReadinessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadinessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadinessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadinessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadinessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadinessResponseValidationError) ErrorName() string {
	return "ReadinessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadinessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadinessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadinessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadinessResponseValidationError{}

// Validate checks the field values on LeaderHealthCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeaderHealthCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaderHealthCheckRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaderHealthCheckRequestMultiError, or nil if none found.
func (m *LeaderHealthCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaderHealthCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LeaderHealthCheckRequestMultiError(errors)
	}

	return nil
}

// LeaderHealthCheckRequestMultiError is an error wrapping multiple validation
// errors returned by LeaderHealthCheckRequest.ValidateAll() if the designated
// constraints aren't met.
type LeaderHealthCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaderHealthCheckRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaderHealthCheckRequestMultiError) AllErrors() []error { return m }

// LeaderHealthCheckRequestValidationError is the validation error returned by
// LeaderHealthCheckRequest.Validate if the designated constraints aren't met.
type LeaderHealthCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaderHealthCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaderHealthCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaderHealthCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaderHealthCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaderHealthCheckRequestValidationError) ErrorName() string {
	return "LeaderHealthCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LeaderHealthCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaderHealthCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaderHealthCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaderHealthCheckRequestValidationError{}

// Validate checks the field values on LeaderHealthCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeaderHealthCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaderHealthCheckResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaderHealthCheckResponseMultiError, or nil if none found.
func (m *LeaderHealthCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaderHealthCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LeaderHealthCheckResponseMultiError(errors)
	}

	return nil
}

// LeaderHealthCheckResponseMultiError is an error wrapping multiple validation
// errors returned by LeaderHealthCheckResponse.ValidateAll() if the
// designated constraints aren't met.
type LeaderHealthCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaderHealthCheckResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaderHealthCheckResponseMultiError) AllErrors() []error { return m }

// LeaderHealthCheckResponseValidationError is the validation error returned by
// LeaderHealthCheckResponse.Validate if the designated constraints aren't met.
type LeaderHealthCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaderHealthCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaderHealthCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaderHealthCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaderHealthCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaderHealthCheckResponseValidationError) ErrorName() string {
	return "LeaderHealthCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LeaderHealthCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaderHealthCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaderHealthCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaderHealthCheckResponseValidationError{}

// Validate checks the field values on CheckUpdatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckUpdatesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckUpdatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckUpdatesRequestMultiError, or nil if none found.
func (m *CheckUpdatesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckUpdatesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Force

	// no validation rules for OnlyInstalledVersion

	if len(errors) > 0 {
		return CheckUpdatesRequestMultiError(errors)
	}

	return nil
}

// CheckUpdatesRequestMultiError is an error wrapping multiple validation
// errors returned by CheckUpdatesRequest.ValidateAll() if the designated
// constraints aren't met.
type CheckUpdatesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckUpdatesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckUpdatesRequestMultiError) AllErrors() []error { return m }

// CheckUpdatesRequestValidationError is the validation error returned by
// CheckUpdatesRequest.Validate if the designated constraints aren't met.
type CheckUpdatesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckUpdatesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckUpdatesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckUpdatesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckUpdatesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckUpdatesRequestValidationError) ErrorName() string {
	return "CheckUpdatesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckUpdatesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckUpdatesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckUpdatesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckUpdatesRequestValidationError{}

// Validate checks the field values on DockerVersionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DockerVersionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DockerVersionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DockerVersionInfoMultiError, or nil if none found.
func (m *DockerVersionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DockerVersionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for Tag

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DockerVersionInfoValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DockerVersionInfoValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DockerVersionInfoValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReleaseNotesUrl

	// no validation rules for ReleaseNotesText

	if len(errors) > 0 {
		return DockerVersionInfoMultiError(errors)
	}

	return nil
}

// DockerVersionInfoMultiError is an error wrapping multiple validation errors
// returned by DockerVersionInfo.ValidateAll() if the designated constraints
// aren't met.
type DockerVersionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DockerVersionInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DockerVersionInfoMultiError) AllErrors() []error { return m }

// DockerVersionInfoValidationError is the validation error returned by
// DockerVersionInfo.Validate if the designated constraints aren't met.
type DockerVersionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DockerVersionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DockerVersionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DockerVersionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DockerVersionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DockerVersionInfoValidationError) ErrorName() string {
	return "DockerVersionInfoValidationError"
}

// Error satisfies the builtin error interface
func (e DockerVersionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDockerVersionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DockerVersionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DockerVersionInfoValidationError{}

// Validate checks the field values on CheckUpdatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckUpdatesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckUpdatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckUpdatesResponseMultiError, or nil if none found.
func (m *CheckUpdatesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckUpdatesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstalled()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "Installed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "Installed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstalled()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckUpdatesResponseValidationError{
				field:  "Installed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLatest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckUpdatesResponseValidationError{
				field:  "Latest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdateAvailable

	// no validation rules for LatestNewsUrl

	if all {
		switch v := interface{}(m.GetLastCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "LastCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "LastCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckUpdatesResponseValidationError{
				field:  "LastCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckUpdatesResponseMultiError(errors)
	}

	return nil
}

// CheckUpdatesResponseMultiError is an error wrapping multiple validation
// errors returned by CheckUpdatesResponse.ValidateAll() if the designated
// constraints aren't met.
type CheckUpdatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckUpdatesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckUpdatesResponseMultiError) AllErrors() []error { return m }

// CheckUpdatesResponseValidationError is the validation error returned by
// CheckUpdatesResponse.Validate if the designated constraints aren't met.
type CheckUpdatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckUpdatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckUpdatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckUpdatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckUpdatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckUpdatesResponseValidationError) ErrorName() string {
	return "CheckUpdatesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckUpdatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckUpdatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckUpdatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckUpdatesResponseValidationError{}

// Validate checks the field values on ListChangeLogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChangeLogsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChangeLogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChangeLogsRequestMultiError, or nil if none found.
func (m *ListChangeLogsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChangeLogsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListChangeLogsRequestMultiError(errors)
	}

	return nil
}

// ListChangeLogsRequestMultiError is an error wrapping multiple validation
// errors returned by ListChangeLogsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListChangeLogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChangeLogsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChangeLogsRequestMultiError) AllErrors() []error { return m }

// ListChangeLogsRequestValidationError is the validation error returned by
// ListChangeLogsRequest.Validate if the designated constraints aren't met.
type ListChangeLogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChangeLogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChangeLogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChangeLogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChangeLogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChangeLogsRequestValidationError) ErrorName() string {
	return "ListChangeLogsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListChangeLogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChangeLogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChangeLogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChangeLogsRequestValidationError{}

// Validate checks the field values on ListChangeLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListChangeLogsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListChangeLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListChangeLogsResponseMultiError, or nil if none found.
func (m *ListChangeLogsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListChangeLogsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUpdates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListChangeLogsResponseValidationError{
						field:  fmt.Sprintf("Updates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListChangeLogsResponseValidationError{
						field:  fmt.Sprintf("Updates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListChangeLogsResponseValidationError{
					field:  fmt.Sprintf("Updates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLastCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListChangeLogsResponseValidationError{
					field:  "LastCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListChangeLogsResponseValidationError{
					field:  "LastCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListChangeLogsResponseValidationError{
				field:  "LastCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListChangeLogsResponseMultiError(errors)
	}

	return nil
}

// ListChangeLogsResponseMultiError is an error wrapping multiple validation
// errors returned by ListChangeLogsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListChangeLogsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListChangeLogsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListChangeLogsResponseMultiError) AllErrors() []error { return m }

// ListChangeLogsResponseValidationError is the validation error returned by
// ListChangeLogsResponse.Validate if the designated constraints aren't met.
type ListChangeLogsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListChangeLogsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListChangeLogsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListChangeLogsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListChangeLogsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListChangeLogsResponseValidationError) ErrorName() string {
	return "ListChangeLogsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListChangeLogsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListChangeLogsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListChangeLogsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListChangeLogsResponseValidationError{}

// Validate checks the field values on StartUpdateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartUpdateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartUpdateRequestMultiError, or nil if none found.
func (m *StartUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NewImage

	if len(errors) > 0 {
		return StartUpdateRequestMultiError(errors)
	}

	return nil
}

// StartUpdateRequestMultiError is an error wrapping multiple validation errors
// returned by StartUpdateRequest.ValidateAll() if the designated constraints
// aren't met.
type StartUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartUpdateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartUpdateRequestMultiError) AllErrors() []error { return m }

// StartUpdateRequestValidationError is the validation error returned by
// StartUpdateRequest.Validate if the designated constraints aren't met.
type StartUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartUpdateRequestValidationError) ErrorName() string {
	return "StartUpdateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartUpdateRequestValidationError{}

// Validate checks the field values on StartUpdateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartUpdateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartUpdateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartUpdateResponseMultiError, or nil if none found.
func (m *StartUpdateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartUpdateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthToken

	// no validation rules for LogOffset

	if len(errors) > 0 {
		return StartUpdateResponseMultiError(errors)
	}

	return nil
}

// StartUpdateResponseMultiError is an error wrapping multiple validation
// errors returned by StartUpdateResponse.ValidateAll() if the designated
// constraints aren't met.
type StartUpdateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartUpdateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartUpdateResponseMultiError) AllErrors() []error { return m }

// StartUpdateResponseValidationError is the validation error returned by
// StartUpdateResponse.Validate if the designated constraints aren't met.
type StartUpdateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartUpdateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartUpdateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartUpdateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartUpdateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartUpdateResponseValidationError) ErrorName() string {
	return "StartUpdateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartUpdateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartUpdateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartUpdateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartUpdateResponseValidationError{}

// Validate checks the field values on UpdateStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateStatusRequestMultiError, or nil if none found.
func (m *UpdateStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthToken

	// no validation rules for LogOffset

	if len(errors) > 0 {
		return UpdateStatusRequestMultiError(errors)
	}

	return nil
}

// UpdateStatusRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStatusRequestMultiError) AllErrors() []error { return m }

// UpdateStatusRequestValidationError is the validation error returned by
// UpdateStatusRequest.Validate if the designated constraints aren't met.
type UpdateStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStatusRequestValidationError) ErrorName() string {
	return "UpdateStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStatusRequestValidationError{}

// Validate checks the field values on UpdateStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateStatusResponseMultiError, or nil if none found.
func (m *UpdateStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LogOffset

	// no validation rules for Done

	if len(errors) > 0 {
		return UpdateStatusResponseMultiError(errors)
	}

	return nil
}

// UpdateStatusResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStatusResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStatusResponseMultiError) AllErrors() []error { return m }

// UpdateStatusResponseValidationError is the validation error returned by
// UpdateStatusResponse.Validate if the designated constraints aren't met.
type UpdateStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStatusResponseValidationError) ErrorName() string {
	return "UpdateStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStatusResponseValidationError{}

// Validate checks the field values on MetricsResolutions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsResolutions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsResolutions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsResolutionsMultiError, or nil if none found.
func (m *MetricsResolutions) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsResolutions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Hr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Hr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsResolutionsValidationError{
				field:  "Hr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Mr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Mr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsResolutionsValidationError{
				field:  "Mr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Lr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Lr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsResolutionsValidationError{
				field:  "Lr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsResolutionsMultiError(errors)
	}

	return nil
}

// MetricsResolutionsMultiError is an error wrapping multiple validation errors
// returned by MetricsResolutions.ValidateAll() if the designated constraints
// aren't met.
type MetricsResolutionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsResolutionsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsResolutionsMultiError) AllErrors() []error { return m }

// MetricsResolutionsValidationError is the validation error returned by
// MetricsResolutions.Validate if the designated constraints aren't met.
type MetricsResolutionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsResolutionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsResolutionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsResolutionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsResolutionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsResolutionsValidationError) ErrorName() string {
	return "MetricsResolutionsValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsResolutionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsResolutions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsResolutionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsResolutionsValidationError{}

// Validate checks the field values on AdvisorRunIntervals with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdvisorRunIntervals) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdvisorRunIntervals with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdvisorRunIntervalsMultiError, or nil if none found.
func (m *AdvisorRunIntervals) ValidateAll() error {
	return m.validate(true)
}

func (m *AdvisorRunIntervals) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStandardInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "StandardInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "StandardInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStandardInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdvisorRunIntervalsValidationError{
				field:  "StandardInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRareInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "RareInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "RareInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRareInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdvisorRunIntervalsValidationError{
				field:  "RareInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFrequentInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "FrequentInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "FrequentInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrequentInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdvisorRunIntervalsValidationError{
				field:  "FrequentInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdvisorRunIntervalsMultiError(errors)
	}

	return nil
}

// AdvisorRunIntervalsMultiError is an error wrapping multiple validation
// errors returned by AdvisorRunIntervals.ValidateAll() if the designated
// constraints aren't met.
type AdvisorRunIntervalsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdvisorRunIntervalsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdvisorRunIntervalsMultiError) AllErrors() []error { return m }

// AdvisorRunIntervalsValidationError is the validation error returned by
// AdvisorRunIntervals.Validate if the designated constraints aren't met.
type AdvisorRunIntervalsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdvisorRunIntervalsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdvisorRunIntervalsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdvisorRunIntervalsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdvisorRunIntervalsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdvisorRunIntervalsValidationError) ErrorName() string {
	return "AdvisorRunIntervalsValidationError"
}

// Error satisfies the builtin error interface
func (e AdvisorRunIntervalsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdvisorRunIntervals.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdvisorRunIntervalsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdvisorRunIntervalsValidationError{}

// Validate checks the field values on Settings with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Settings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Settings with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SettingsMultiError, or nil
// if none found.
func (m *Settings) ValidateAll() error {
	return m.validate(true)
}

func (m *Settings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UpdatesEnabled

	// no validation rules for TelemetryEnabled

	if all {
		switch v := interface{}(m.GetMetricsResolutions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "MetricsResolutions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "MetricsResolutions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetricsResolutions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettingsValidationError{
				field:  "MetricsResolutions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDataRetention()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "DataRetention",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "DataRetention",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataRetention()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettingsValidationError{
				field:  "DataRetention",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SshKey

	// no validation rules for AdvisorEnabled

	// no validation rules for PlatformEmail

	// no validation rules for AlertingEnabled

	// no validation rules for PmmPublicAddress

	if all {
		switch v := interface{}(m.GetAdvisorRunIntervals()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "AdvisorRunIntervals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "AdvisorRunIntervals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdvisorRunIntervals()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettingsValidationError{
				field:  "AdvisorRunIntervals",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BackupManagementEnabled

	// no validation rules for AzurediscoverEnabled

	// no validation rules for ConnectedToPlatform

	// no validation rules for EnableAccessControl

	// no validation rules for DefaultRoleId

	if len(errors) > 0 {
		return SettingsMultiError(errors)
	}

	return nil
}

// SettingsMultiError is an error wrapping multiple validation errors returned
// by Settings.ValidateAll() if the designated constraints aren't met.
type SettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettingsMultiError) AllErrors() []error { return m }

// SettingsValidationError is the validation error returned by
// Settings.Validate if the designated constraints aren't met.
type SettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettingsValidationError) ErrorName() string { return "SettingsValidationError" }

// Error satisfies the builtin error interface
func (e SettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettingsValidationError{}

// Validate checks the field values on ReadOnlySettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadOnlySettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadOnlySettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadOnlySettingsMultiError, or nil if none found.
func (m *ReadOnlySettings) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadOnlySettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UpdatesEnabled

	// no validation rules for TelemetryEnabled

	// no validation rules for AdvisorEnabled

	// no validation rules for AlertingEnabled

	// no validation rules for PmmPublicAddress

	// no validation rules for BackupManagementEnabled

	// no validation rules for AzurediscoverEnabled

	// no validation rules for EnableAccessControl

	if len(errors) > 0 {
		return ReadOnlySettingsMultiError(errors)
	}

	return nil
}

// ReadOnlySettingsMultiError is an error wrapping multiple validation errors
// returned by ReadOnlySettings.ValidateAll() if the designated constraints
// aren't met.
type ReadOnlySettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadOnlySettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadOnlySettingsMultiError) AllErrors() []error { return m }

// ReadOnlySettingsValidationError is the validation error returned by
// ReadOnlySettings.Validate if the designated constraints aren't met.
type ReadOnlySettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadOnlySettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadOnlySettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadOnlySettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadOnlySettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadOnlySettingsValidationError) ErrorName() string { return "ReadOnlySettingsValidationError" }

// Error satisfies the builtin error interface
func (e ReadOnlySettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadOnlySettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadOnlySettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadOnlySettingsValidationError{}

// Validate checks the field values on GetSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSettingsRequestMultiError, or nil if none found.
func (m *GetSettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetSettingsRequestMultiError(errors)
	}

	return nil
}

// GetSettingsRequestMultiError is an error wrapping multiple validation errors
// returned by GetSettingsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSettingsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSettingsRequestMultiError) AllErrors() []error { return m }

// GetSettingsRequestValidationError is the validation error returned by
// GetSettingsRequest.Validate if the designated constraints aren't met.
type GetSettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSettingsRequestValidationError) ErrorName() string {
	return "GetSettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSettingsRequestValidationError{}

// Validate checks the field values on GetReadOnlySettingsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReadOnlySettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReadOnlySettingsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReadOnlySettingsRequestMultiError, or nil if none found.
func (m *GetReadOnlySettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReadOnlySettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetReadOnlySettingsRequestMultiError(errors)
	}

	return nil
}

// GetReadOnlySettingsRequestMultiError is an error wrapping multiple
// validation errors returned by GetReadOnlySettingsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetReadOnlySettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReadOnlySettingsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReadOnlySettingsRequestMultiError) AllErrors() []error { return m }

// GetReadOnlySettingsRequestValidationError is the validation error returned
// by GetReadOnlySettingsRequest.Validate if the designated constraints aren't met.
type GetReadOnlySettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReadOnlySettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReadOnlySettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReadOnlySettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReadOnlySettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReadOnlySettingsRequestValidationError) ErrorName() string {
	return "GetReadOnlySettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReadOnlySettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReadOnlySettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReadOnlySettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReadOnlySettingsRequestValidationError{}

// Validate checks the field values on GetSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSettingsResponseMultiError, or nil if none found.
func (m *GetSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSettingsResponseValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSettingsResponseMultiError(errors)
	}

	return nil
}

// GetSettingsResponseMultiError is an error wrapping multiple validation
// errors returned by GetSettingsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSettingsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSettingsResponseMultiError) AllErrors() []error { return m }

// GetSettingsResponseValidationError is the validation error returned by
// GetSettingsResponse.Validate if the designated constraints aren't met.
type GetSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSettingsResponseValidationError) ErrorName() string {
	return "GetSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSettingsResponseValidationError{}

// Validate checks the field values on GetReadOnlySettingsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReadOnlySettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReadOnlySettingsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReadOnlySettingsResponseMultiError, or nil if none found.
func (m *GetReadOnlySettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReadOnlySettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReadOnlySettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReadOnlySettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReadOnlySettingsResponseValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReadOnlySettingsResponseMultiError(errors)
	}

	return nil
}

// GetReadOnlySettingsResponseMultiError is an error wrapping multiple
// validation errors returned by GetReadOnlySettingsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetReadOnlySettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReadOnlySettingsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReadOnlySettingsResponseMultiError) AllErrors() []error { return m }

// GetReadOnlySettingsResponseValidationError is the validation error returned
// by GetReadOnlySettingsResponse.Validate if the designated constraints
// aren't met.
type GetReadOnlySettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReadOnlySettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReadOnlySettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReadOnlySettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReadOnlySettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReadOnlySettingsResponseValidationError) ErrorName() string {
	return "GetReadOnlySettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReadOnlySettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReadOnlySettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReadOnlySettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReadOnlySettingsResponseValidationError{}

// Validate checks the field values on ChangeSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeSettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeSettingsRequestMultiError, or nil if none found.
func (m *ChangeSettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeSettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetricsResolutions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "MetricsResolutions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "MetricsResolutions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetricsResolutions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSettingsRequestValidationError{
				field:  "MetricsResolutions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDataRetention()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "DataRetention",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "DataRetention",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataRetention()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSettingsRequestValidationError{
				field:  "DataRetention",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdvisorRunIntervals()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "AdvisorRunIntervals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "AdvisorRunIntervals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdvisorRunIntervals()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSettingsRequestValidationError{
				field:  "AdvisorRunIntervals",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EnableUpdates != nil {
		// no validation rules for EnableUpdates
	}

	if m.EnableTelemetry != nil {
		// no validation rules for EnableTelemetry
	}

	if m.SshKey != nil {
		// no validation rules for SshKey
	}

	if m.AwsPartitions != nil {
		if all {
			switch v := interface{}(m.GetAwsPartitions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChangeSettingsRequestValidationError{
						field:  "AwsPartitions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChangeSettingsRequestValidationError{
						field:  "AwsPartitions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAwsPartitions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChangeSettingsRequestValidationError{
					field:  "AwsPartitions",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}
	}

	if m.EnableAdvisor != nil {
		// no validation rules for EnableAdvisor
	}

	if m.EnableAlerting != nil {
		// no validation rules for EnableAlerting
	}

	if m.PmmPublicAddress != nil {
		// no validation rules for PmmPublicAddress
	}

	if m.EnableAzurediscover != nil {
		// no validation rules for EnableAzurediscover
	}

	if m.EnableBackupManagement != nil {
		// no validation rules for EnableBackupManagement
	}

	if m.EnableAccessControl != nil {
		// no validation rules for EnableAccessControl
	}

	if len(errors) > 0 {
		return ChangeSettingsRequestMultiError(errors)
	}

	return nil
}

// ChangeSettingsRequestMultiError is an error wrapping multiple validation
// errors returned by ChangeSettingsRequest.ValidateAll() if the designated
// constraints aren't met.
type ChangeSettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeSettingsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeSettingsRequestMultiError) AllErrors() []error { return m }

// ChangeSettingsRequestValidationError is the validation error returned by
// ChangeSettingsRequest.Validate if the designated constraints aren't met.
type ChangeSettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeSettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeSettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeSettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeSettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeSettingsRequestValidationError) ErrorName() string {
	return "ChangeSettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeSettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeSettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeSettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeSettingsRequestValidationError{}

// Validate checks the field values on ChangeSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeSettingsResponseMultiError, or nil if none found.
func (m *ChangeSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSettingsResponseValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChangeSettingsResponseMultiError(errors)
	}

	return nil
}

// ChangeSettingsResponseMultiError is an error wrapping multiple validation
// errors returned by ChangeSettingsResponse.ValidateAll() if the designated
// constraints aren't met.
type ChangeSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeSettingsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeSettingsResponseMultiError) AllErrors() []error { return m }

// ChangeSettingsResponseValidationError is the validation error returned by
// ChangeSettingsResponse.Validate if the designated constraints aren't met.
type ChangeSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeSettingsResponseValidationError) ErrorName() string {
	return "ChangeSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeSettingsResponseValidationError{}
