// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: server/v1/server.proto

package serverv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on VersionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VersionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VersionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VersionInfoMultiError, or
// nil if none found.
func (m *VersionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *VersionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for FullVersion

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionInfoValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionInfoValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionInfoValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VersionInfoMultiError(errors)
	}

	return nil
}

// VersionInfoMultiError is an error wrapping multiple validation errors
// returned by VersionInfo.ValidateAll() if the designated constraints aren't met.
type VersionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionInfoMultiError) AllErrors() []error { return m }

// VersionInfoValidationError is the validation error returned by
// VersionInfo.Validate if the designated constraints aren't met.
type VersionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionInfoValidationError) ErrorName() string { return "VersionInfoValidationError" }

// Error satisfies the builtin error interface
func (e VersionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionInfoValidationError{}

// Validate checks the field values on VersionRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VersionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VersionRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VersionRequestMultiError,
// or nil if none found.
func (m *VersionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VersionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dummy

	if len(errors) > 0 {
		return VersionRequestMultiError(errors)
	}

	return nil
}

// VersionRequestMultiError is an error wrapping multiple validation errors
// returned by VersionRequest.ValidateAll() if the designated constraints
// aren't met.
type VersionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionRequestMultiError) AllErrors() []error { return m }

// VersionRequestValidationError is the validation error returned by
// VersionRequest.Validate if the designated constraints aren't met.
type VersionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionRequestValidationError) ErrorName() string { return "VersionRequestValidationError" }

// Error satisfies the builtin error interface
func (e VersionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionRequestValidationError{}

// Validate checks the field values on VersionResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VersionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VersionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VersionResponseMultiError, or nil if none found.
func (m *VersionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VersionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetServer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionResponseValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionResponseValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionResponseValidationError{
				field:  "Server",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetManaged()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionResponseValidationError{
					field:  "Managed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionResponseValidationError{
					field:  "Managed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetManaged()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionResponseValidationError{
				field:  "Managed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DistributionMethod

	if len(errors) > 0 {
		return VersionResponseMultiError(errors)
	}

	return nil
}

// VersionResponseMultiError is an error wrapping multiple validation errors
// returned by VersionResponse.ValidateAll() if the designated constraints
// aren't met.
type VersionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionResponseMultiError) AllErrors() []error { return m }

// VersionResponseValidationError is the validation error returned by
// VersionResponse.Validate if the designated constraints aren't met.
type VersionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionResponseValidationError) ErrorName() string { return "VersionResponseValidationError" }

// Error satisfies the builtin error interface
func (e VersionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionResponseValidationError{}

// Validate checks the field values on ReadinessResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadinessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadinessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadinessResponseMultiError, or nil if none found.
func (m *ReadinessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadinessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReadinessResponseMultiError(errors)
	}

	return nil
}

// ReadinessResponseMultiError is an error wrapping multiple validation errors
// returned by ReadinessResponse.ValidateAll() if the designated constraints
// aren't met.
type ReadinessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadinessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadinessResponseMultiError) AllErrors() []error { return m }

// ReadinessResponseValidationError is the validation error returned by
// ReadinessResponse.Validate if the designated constraints aren't met.
type ReadinessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadinessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadinessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadinessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadinessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadinessResponseValidationError) ErrorName() string {
	return "ReadinessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadinessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadinessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadinessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadinessResponseValidationError{}

// Validate checks the field values on LeaderHealthCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeaderHealthCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaderHealthCheckResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaderHealthCheckResponseMultiError, or nil if none found.
func (m *LeaderHealthCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaderHealthCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LeaderHealthCheckResponseMultiError(errors)
	}

	return nil
}

// LeaderHealthCheckResponseMultiError is an error wrapping multiple validation
// errors returned by LeaderHealthCheckResponse.ValidateAll() if the
// designated constraints aren't met.
type LeaderHealthCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaderHealthCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaderHealthCheckResponseMultiError) AllErrors() []error { return m }

// LeaderHealthCheckResponseValidationError is the validation error returned by
// LeaderHealthCheckResponse.Validate if the designated constraints aren't met.
type LeaderHealthCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaderHealthCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaderHealthCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaderHealthCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaderHealthCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaderHealthCheckResponseValidationError) ErrorName() string {
	return "LeaderHealthCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LeaderHealthCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaderHealthCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaderHealthCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaderHealthCheckResponseValidationError{}

// Validate checks the field values on CheckUpdatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckUpdatesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckUpdatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckUpdatesRequestMultiError, or nil if none found.
func (m *CheckUpdatesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckUpdatesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Force

	// no validation rules for OnlyInstalledVersion

	if len(errors) > 0 {
		return CheckUpdatesRequestMultiError(errors)
	}

	return nil
}

// CheckUpdatesRequestMultiError is an error wrapping multiple validation
// errors returned by CheckUpdatesRequest.ValidateAll() if the designated
// constraints aren't met.
type CheckUpdatesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckUpdatesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckUpdatesRequestMultiError) AllErrors() []error { return m }

// CheckUpdatesRequestValidationError is the validation error returned by
// CheckUpdatesRequest.Validate if the designated constraints aren't met.
type CheckUpdatesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckUpdatesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckUpdatesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckUpdatesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckUpdatesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckUpdatesRequestValidationError) ErrorName() string {
	return "CheckUpdatesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckUpdatesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckUpdatesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckUpdatesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckUpdatesRequestValidationError{}

// Validate checks the field values on CheckUpdatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckUpdatesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckUpdatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckUpdatesResponseMultiError, or nil if none found.
func (m *CheckUpdatesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckUpdatesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstalled()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "Installed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "Installed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstalled()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckUpdatesResponseValidationError{
				field:  "Installed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLatest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckUpdatesResponseValidationError{
				field:  "Latest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdateAvailable

	// no validation rules for LatestNewsUrl

	if all {
		switch v := interface{}(m.GetLastCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "LastCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckUpdatesResponseValidationError{
					field:  "LastCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckUpdatesResponseValidationError{
				field:  "LastCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckUpdatesResponseMultiError(errors)
	}

	return nil
}

// CheckUpdatesResponseMultiError is an error wrapping multiple validation
// errors returned by CheckUpdatesResponse.ValidateAll() if the designated
// constraints aren't met.
type CheckUpdatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckUpdatesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckUpdatesResponseMultiError) AllErrors() []error { return m }

// CheckUpdatesResponseValidationError is the validation error returned by
// CheckUpdatesResponse.Validate if the designated constraints aren't met.
type CheckUpdatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckUpdatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckUpdatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckUpdatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckUpdatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckUpdatesResponseValidationError) ErrorName() string {
	return "CheckUpdatesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckUpdatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckUpdatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckUpdatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckUpdatesResponseValidationError{}

// Validate checks the field values on StartUpdateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartUpdateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartUpdateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartUpdateResponseMultiError, or nil if none found.
func (m *StartUpdateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartUpdateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthToken

	// no validation rules for LogOffset

	if len(errors) > 0 {
		return StartUpdateResponseMultiError(errors)
	}

	return nil
}

// StartUpdateResponseMultiError is an error wrapping multiple validation
// errors returned by StartUpdateResponse.ValidateAll() if the designated
// constraints aren't met.
type StartUpdateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartUpdateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartUpdateResponseMultiError) AllErrors() []error { return m }

// StartUpdateResponseValidationError is the validation error returned by
// StartUpdateResponse.Validate if the designated constraints aren't met.
type StartUpdateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartUpdateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartUpdateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartUpdateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartUpdateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartUpdateResponseValidationError) ErrorName() string {
	return "StartUpdateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartUpdateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartUpdateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartUpdateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartUpdateResponseValidationError{}

// Validate checks the field values on UpdateStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateStatusRequestMultiError, or nil if none found.
func (m *UpdateStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthToken

	// no validation rules for LogOffset

	if len(errors) > 0 {
		return UpdateStatusRequestMultiError(errors)
	}

	return nil
}

// UpdateStatusRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStatusRequestMultiError) AllErrors() []error { return m }

// UpdateStatusRequestValidationError is the validation error returned by
// UpdateStatusRequest.Validate if the designated constraints aren't met.
type UpdateStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStatusRequestValidationError) ErrorName() string {
	return "UpdateStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStatusRequestValidationError{}

// Validate checks the field values on UpdateStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateStatusResponseMultiError, or nil if none found.
func (m *UpdateStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LogOffset

	// no validation rules for Done

	if len(errors) > 0 {
		return UpdateStatusResponseMultiError(errors)
	}

	return nil
}

// UpdateStatusResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStatusResponseMultiError) AllErrors() []error { return m }

// UpdateStatusResponseValidationError is the validation error returned by
// UpdateStatusResponse.Validate if the designated constraints aren't met.
type UpdateStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStatusResponseValidationError) ErrorName() string {
	return "UpdateStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStatusResponseValidationError{}

// Validate checks the field values on MetricsResolutions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsResolutions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsResolutions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsResolutionsMultiError, or nil if none found.
func (m *MetricsResolutions) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsResolutions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Hr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Hr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsResolutionsValidationError{
				field:  "Hr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Mr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Mr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsResolutionsValidationError{
				field:  "Mr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Lr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsResolutionsValidationError{
					field:  "Lr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsResolutionsValidationError{
				field:  "Lr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsResolutionsMultiError(errors)
	}

	return nil
}

// MetricsResolutionsMultiError is an error wrapping multiple validation errors
// returned by MetricsResolutions.ValidateAll() if the designated constraints
// aren't met.
type MetricsResolutionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsResolutionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsResolutionsMultiError) AllErrors() []error { return m }

// MetricsResolutionsValidationError is the validation error returned by
// MetricsResolutions.Validate if the designated constraints aren't met.
type MetricsResolutionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsResolutionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsResolutionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsResolutionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsResolutionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsResolutionsValidationError) ErrorName() string {
	return "MetricsResolutionsValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsResolutionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsResolutions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsResolutionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsResolutionsValidationError{}

// Validate checks the field values on AdvisorRunIntervals with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdvisorRunIntervals) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdvisorRunIntervals with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdvisorRunIntervalsMultiError, or nil if none found.
func (m *AdvisorRunIntervals) ValidateAll() error {
	return m.validate(true)
}

func (m *AdvisorRunIntervals) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStandardInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "StandardInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "StandardInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStandardInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdvisorRunIntervalsValidationError{
				field:  "StandardInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRareInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "RareInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "RareInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRareInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdvisorRunIntervalsValidationError{
				field:  "RareInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFrequentInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "FrequentInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdvisorRunIntervalsValidationError{
					field:  "FrequentInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrequentInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdvisorRunIntervalsValidationError{
				field:  "FrequentInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdvisorRunIntervalsMultiError(errors)
	}

	return nil
}

// AdvisorRunIntervalsMultiError is an error wrapping multiple validation
// errors returned by AdvisorRunIntervals.ValidateAll() if the designated
// constraints aren't met.
type AdvisorRunIntervalsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdvisorRunIntervalsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdvisorRunIntervalsMultiError) AllErrors() []error { return m }

// AdvisorRunIntervalsValidationError is the validation error returned by
// AdvisorRunIntervals.Validate if the designated constraints aren't met.
type AdvisorRunIntervalsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdvisorRunIntervalsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdvisorRunIntervalsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdvisorRunIntervalsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdvisorRunIntervalsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdvisorRunIntervalsValidationError) ErrorName() string {
	return "AdvisorRunIntervalsValidationError"
}

// Error satisfies the builtin error interface
func (e AdvisorRunIntervalsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdvisorRunIntervals.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdvisorRunIntervalsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdvisorRunIntervalsValidationError{}

// Validate checks the field values on Settings with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Settings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Settings with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SettingsMultiError, or nil
// if none found.
func (m *Settings) ValidateAll() error {
	return m.validate(true)
}

func (m *Settings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UpdatesEnabled

	// no validation rules for TelemetryEnabled

	if all {
		switch v := interface{}(m.GetMetricsResolutions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "MetricsResolutions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "MetricsResolutions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetricsResolutions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettingsValidationError{
				field:  "MetricsResolutions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDataRetention()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "DataRetention",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "DataRetention",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataRetention()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettingsValidationError{
				field:  "DataRetention",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SshKey

	// no validation rules for AdvisorEnabled

	// no validation rules for PlatformEmail

	// no validation rules for AlertingEnabled

	// no validation rules for PmmPublicAddress

	if all {
		switch v := interface{}(m.GetAdvisorRunIntervals()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "AdvisorRunIntervals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettingsValidationError{
					field:  "AdvisorRunIntervals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdvisorRunIntervals()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettingsValidationError{
				field:  "AdvisorRunIntervals",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BackupManagementEnabled

	// no validation rules for AzurediscoverEnabled

	// no validation rules for ConnectedToPlatform

	// no validation rules for EnableAccessControl

	// no validation rules for DefaultRoleId

	if len(errors) > 0 {
		return SettingsMultiError(errors)
	}

	return nil
}

// SettingsMultiError is an error wrapping multiple validation errors returned
// by Settings.ValidateAll() if the designated constraints aren't met.
type SettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettingsMultiError) AllErrors() []error { return m }

// SettingsValidationError is the validation error returned by
// Settings.Validate if the designated constraints aren't met.
type SettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettingsValidationError) ErrorName() string { return "SettingsValidationError" }

// Error satisfies the builtin error interface
func (e SettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettingsValidationError{}

// Validate checks the field values on GetSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSettingsResponseMultiError, or nil if none found.
func (m *GetSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSettingsResponseValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSettingsResponseMultiError(errors)
	}

	return nil
}

// GetSettingsResponseMultiError is an error wrapping multiple validation
// errors returned by GetSettingsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSettingsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSettingsResponseMultiError) AllErrors() []error { return m }

// GetSettingsResponseValidationError is the validation error returned by
// GetSettingsResponse.Validate if the designated constraints aren't met.
type GetSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSettingsResponseValidationError) ErrorName() string {
	return "GetSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSettingsResponseValidationError{}

// Validate checks the field values on ChangeSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeSettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeSettingsRequestMultiError, or nil if none found.
func (m *ChangeSettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeSettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetricsResolutions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "MetricsResolutions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "MetricsResolutions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetricsResolutions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSettingsRequestValidationError{
				field:  "MetricsResolutions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDataRetention()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "DataRetention",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "DataRetention",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataRetention()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSettingsRequestValidationError{
				field:  "DataRetention",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdvisorRunIntervals()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "AdvisorRunIntervals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSettingsRequestValidationError{
					field:  "AdvisorRunIntervals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdvisorRunIntervals()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSettingsRequestValidationError{
				field:  "AdvisorRunIntervals",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EnableUpdates != nil {
		// no validation rules for EnableUpdates
	}

	if m.EnableTelemetry != nil {
		// no validation rules for EnableTelemetry
	}

	if m.SshKey != nil {
		// no validation rules for SshKey
	}

	if m.AwsPartitions != nil {
		if all {
			switch v := interface{}(m.GetAwsPartitions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChangeSettingsRequestValidationError{
						field:  "AwsPartitions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChangeSettingsRequestValidationError{
						field:  "AwsPartitions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAwsPartitions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChangeSettingsRequestValidationError{
					field:  "AwsPartitions",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}
	}

	if m.EnableAdvisor != nil {
		// no validation rules for EnableAdvisor
	}

	if m.EnableAlerting != nil {
		// no validation rules for EnableAlerting
	}

	if m.PmmPublicAddress != nil {
		// no validation rules for PmmPublicAddress
	}

	if m.EnableAzurediscover != nil {
		// no validation rules for EnableAzurediscover
	}

	if m.EnableBackupManagement != nil {
		// no validation rules for EnableBackupManagement
	}

	if m.EnableAccessControl != nil {
		// no validation rules for EnableAccessControl
	}

	if len(errors) > 0 {
		return ChangeSettingsRequestMultiError(errors)
	}

	return nil
}

// ChangeSettingsRequestMultiError is an error wrapping multiple validation
// errors returned by ChangeSettingsRequest.ValidateAll() if the designated
// constraints aren't met.
type ChangeSettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeSettingsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeSettingsRequestMultiError) AllErrors() []error { return m }

// ChangeSettingsRequestValidationError is the validation error returned by
// ChangeSettingsRequest.Validate if the designated constraints aren't met.
type ChangeSettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeSettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeSettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeSettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeSettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeSettingsRequestValidationError) ErrorName() string {
	return "ChangeSettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeSettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeSettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeSettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeSettingsRequestValidationError{}

// Validate checks the field values on ChangeSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeSettingsResponseMultiError, or nil if none found.
func (m *ChangeSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeSettingsResponseValidationError{
					field:  "Settings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeSettingsResponseValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChangeSettingsResponseMultiError(errors)
	}

	return nil
}

// ChangeSettingsResponseMultiError is an error wrapping multiple validation
// errors returned by ChangeSettingsResponse.ValidateAll() if the designated
// constraints aren't met.
type ChangeSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeSettingsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeSettingsResponseMultiError) AllErrors() []error { return m }

// ChangeSettingsResponseValidationError is the validation error returned by
// ChangeSettingsResponse.Validate if the designated constraints aren't met.
type ChangeSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeSettingsResponseValidationError) ErrorName() string {
	return "ChangeSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeSettingsResponseValidationError{}

// Validate checks the field values on AWSInstanceCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AWSInstanceCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AWSInstanceCheckRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AWSInstanceCheckRequestMultiError, or nil if none found.
func (m *AWSInstanceCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AWSInstanceCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInstanceId()) < 1 {
		err := AWSInstanceCheckRequestValidationError{
			field:  "InstanceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AWSInstanceCheckRequestMultiError(errors)
	}

	return nil
}

// AWSInstanceCheckRequestMultiError is an error wrapping multiple validation
// errors returned by AWSInstanceCheckRequest.ValidateAll() if the designated
// constraints aren't met.
type AWSInstanceCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AWSInstanceCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AWSInstanceCheckRequestMultiError) AllErrors() []error { return m }

// AWSInstanceCheckRequestValidationError is the validation error returned by
// AWSInstanceCheckRequest.Validate if the designated constraints aren't met.
type AWSInstanceCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AWSInstanceCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AWSInstanceCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AWSInstanceCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AWSInstanceCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AWSInstanceCheckRequestValidationError) ErrorName() string {
	return "AWSInstanceCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AWSInstanceCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAWSInstanceCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AWSInstanceCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AWSInstanceCheckRequestValidationError{}
